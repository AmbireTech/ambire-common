// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.19;

import './AmbireAccount.sol';
import './ExternalSigValidator.sol';
import './libs/erc4337/IPaymaster.sol';

contract AmbirePaymaster is IPaymaster {
	address immutable public relayer;

	constructor(address _relayer) {
		relayer = _relayer;
	}

	function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)
		external
		view
		returns (bytes memory context, uint256 validationData)
	{
		// unused stuff
		(userOpHash, maxCost);

		// parse the paymasterAndData
		(uint48 validUntil, uint48 validAfter, bytes memory signature) = abi.decode(userOp.paymasterAndData[20:], (uint48, uint48, bytes));

		// NOTE: we do not need to send funds to the EntryPoint because we rely on pre-existing deposit
		bytes32 hash = keccak256(abi.encode(
			block.chainid,
			address(this),
			validUntil,
			validAfter,
			// everything except paymasterAndData and signature
			userOp.sender,
			// for the nonce we have an exception case: one-time nonces depend on paymasterAndData, which is generated by the relayer
			// we can't have this as part of the sig cuz we create a cyclical dep
			// the nonce can only be used once, so one cannot replay the gas payment
			bytes4(userOp.callData[0:4]) == AmbireAccount.execute.selector ? 0 : userOp.nonce,
			userOp.initCode,
			userOp.callData,
			userOp.callGasLimit,
			userOp.verificationGasLimit,
			userOp.preVerificationGas,
			userOp.maxFeePerGas,
			userOp.maxPriorityFeePerGas
		));
		bool isValidSig = SignatureValidator.recoverAddr(hash, signature) == relayer;
		// see _packValidationData: https://github.com/eth-infinitism/account-abstraction/blob/f2b09e60a92d5b3177c68d9f382912ccac19e8db/contracts/core/Helpers.sol#L73-L80
		return ("", uint160(isValidSig ? 0 : 1) | (uint256(validUntil) << 160) | (uint256(validAfter) << (208)));
	}

	function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external {
		// No-op, won't be used because we don't return a context
	}
}