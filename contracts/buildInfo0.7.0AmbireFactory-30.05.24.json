{
  "language": "Solidity",
  "sources": {
    "src/AmbireAccount.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport './libs/SignatureValidator.sol';\nimport './ExternalSigValidator.sol';\nimport './libs/erc4337/PackedUserOperation.sol';\nimport './libs/erc4337/UserOpHelper.sol';\nimport './deployless/IAmbireAccount.sol';\n\n/**\n * @notice  A validator that performs DKIM signature recovery\n * @dev     All external/public functions (that are not view/pure) use `payable` because AmbireAccount\n * is a wallet contract, and any ETH sent to it is not lost, but on the other hand not having `payable`\n * makes the Solidity compiler add an extra check for `msg.value`, which in this case is wasted gas\n */\ncontract AmbireAccount is IAmbireAccount {\n\t// @dev We do not have a constructor. This contract cannot be initialized with any valid `privileges` by itself!\n\t// The intended use case is to deploy one base implementation contract, and create a minimal proxy for each user wallet, by\n\t// using our own code generation to insert SSTOREs to initialize `privileges` (it was previously called IdentityProxyDeploy.js, now src/libs/proxyDeploy/deploy.ts)\n\taddress private constant FALLBACK_HANDLER_SLOT = address(0x6969);\n\n\t// @dev This is how we understand if msg.sender is the entry point\n\tbytes32 private constant ENTRY_POINT_MARKER = 0x0000000000000000000000000000000000000000000000000000000000007171;\n\n\t// Externally validated signatures\n\tuint8 private constant SIGMODE_EXTERNALLY_VALIDATED = 255;\n\n\t// Variables\n\tmapping(address => bytes32) public privileges;\n\tuint256 public nonce;\n\n\t// Events\n\tevent LogPrivilegeChanged(address indexed addr, bytes32 priv);\n\tevent LogErr(address indexed to, uint256 value, bytes data, bytes returnData); // only used in tryCatch\n\n\t// This contract can accept ETH without calldata\n\treceive() external payable {}\n\n\t/**\n\t * @dev     To support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\t * @return  bytes4  onERC721Received function selector\n\t */\n\tfunction onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n\t\treturn this.onERC721Received.selector;\n\t}\n\n\t/**\n\t * @dev     To support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\t * @return  bytes4  onERC1155Received function selector\n\t */\n\tfunction onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n\t\treturn this.onERC1155Received.selector;\n\t}\n\n\t/**\n\t * @dev     To support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\t * @return  bytes4  onERC1155Received function selector\n\t */\n\tfunction onERC1155BatchReceived(\n\t\taddress,\n\t\taddress,\n\t\tuint256[] calldata,\n\t\tuint256[] calldata,\n\t\tbytes calldata\n\t) external pure returns (bytes4) {\n\t\treturn this.onERC1155BatchReceived.selector;\n\t}\n\n\t/**\n\t * @notice  fallback method: currently used to call the fallback handler\n\t * which is set by the user and can be changed\n\t * @dev     this contract can accept ETH with calldata, hence payable\n\t */\n\tfallback() external payable {\n\t\t// We store the fallback handler at this magic slot\n\t\taddress fallbackHandler = address(uint160(uint(privileges[FALLBACK_HANDLER_SLOT])));\n\t\tif (fallbackHandler == address(0)) return;\n\t\tassembly {\n\t\t\t// we can use addr 0 because logic is taking full control of the\n\t\t\t// execution making sure it returns itself and does not\n\t\t\t// rely on any further Solidity code.\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\tlet result := delegatecall(gas(), fallbackHandler, 0, calldatasize(), 0, 0)\n\t\t\tlet size := returndatasize()\n\t\t\treturndatacopy(0, 0, size)\n\t\t\tif eq(result, 0) {\n\t\t\t\trevert(0, size)\n\t\t\t}\n\t\t\treturn(0, size)\n\t\t}\n\t}\n\n\t/**\n\t * @notice  used to set the privilege of a key (by `addr`)\n\t * @dev     normal signatures will be considered valid if the\n\t * `addr` they are signed with has non-zero (not 0x000..000) privilege set; we can set the privilege to\n\t * a hash of the recovery keys and timelock (see `RecoveryInfo`) to enable recovery signatures\n\t * @param   addr  the address to give privs to\n\t * @param   priv  the privs to give\n\t */\n\tfunction setAddrPrivilege(address addr, bytes32 priv) external payable {\n\t\trequire(msg.sender == address(this), 'ONLY_ACCOUNT_CAN_CALL');\n\t\tprivileges[addr] = priv;\n\t\temit LogPrivilegeChanged(addr, priv);\n\t}\n\n\t/**\n\t * @notice  Useful when we need to do multiple operations but ignore failures in some of them\n\t * @param   to  address we're sending value to\n\t * @param   value  the amount\n\t * @param   data  callData\n\t */\n\tfunction tryCatch(address to, uint256 value, bytes calldata data) external payable {\n\t\trequire(msg.sender == address(this), 'ONLY_ACCOUNT_CAN_CALL');\n\t\tuint256 gasBefore = gasleft();\n\t\t(bool success, bytes memory returnData) = to.call{ value: value, gas: gasBefore }(data);\n\t\trequire(gasleft() > gasBefore / 64, 'TRYCATCH_OOG');\n\t\tif (!success) emit LogErr(to, value, data, returnData);\n\t}\n\n\t/**\n\t * @notice  same as `tryCatch` but with a gas limit\n\t * @param   to  address we're sending value to\n\t * @param   value  the amount\n\t * @param   data  callData\n\t * @param   gasLimit  how much gas is allowed\n\t */\n\tfunction tryCatchLimit(address to, uint256 value, bytes calldata data, uint256 gasLimit) external payable {\n\t\trequire(msg.sender == address(this), 'ONLY_ACCOUNT_CAN_CALL');\n\t\tuint256 gasBefore = gasleft();\n\t\t(bool success, bytes memory returnData) = to.call{ value: value, gas: gasLimit }(data);\n\t\trequire(gasleft() > gasBefore / 64, 'TRYCATCH_OOG');\n\t\tif (!success) emit LogErr(to, value, data, returnData);\n\t}\n\n\t/**\n\t * @notice  execute: this method is used to execute a single bundle of calls that are signed with a key\n\t * that is authorized to execute on this account (in `privileges`)\n\t * @dev     WARNING: if the signature of this is changed, we have to change AmbireAccountFactory\n\t * @param   calls  the transaction we're executing. They may not execute\n\t * if specific cases. One such is when setting a timelock\n\t * @param   signature  the signature for the transactions\n\t */\n\tfunction execute(Transaction[] calldata calls, bytes calldata signature) public payable {\n\t\taddress signerKey;\n\t\tuint8 sigMode = uint8(signature[signature.length - 1]);\n\t\tuint256 currentNonce = nonce;\n\t\t// we increment the nonce here (not using `nonce++` to save some gas)\n\t\tnonce = currentNonce + 1;\n\n\t\tif (sigMode == SIGMODE_EXTERNALLY_VALIDATED) {\n\t\t\tbool isValidSig;\n\t\t\tuint256 timestampValidAfter;\n\t\t\t(signerKey, isValidSig, timestampValidAfter) = validateExternalSig(calls, signature);\n\t\t\tif (!isValidSig) {\n\t\t\t\trequire(block.timestamp >= timestampValidAfter, 'SIGNATURE_VALIDATION_TIMELOCK');\n\t\t\t\trevert('SIGNATURE_VALIDATION_FAIL');\n\t\t\t}\n\t\t} else {\n\t\t\tsignerKey = SignatureValidator.recoverAddr(\n\t\t\t\tkeccak256(abi.encode(address(this), block.chainid, currentNonce, calls)),\n\t\t\t\tsignature,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\trequire(privileges[signerKey] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\t}\n\n\t\texecuteBatch(calls);\n\n\t\t// The actual anti-bricking mechanism - do not allow a signerKey to drop their own privileges\n\t\trequire(privileges[signerKey] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t/**\n\t * @notice  allows executing multiple bundles of calls (batch together multiple executes)\n\t * @param   toExec  an array of execute function parameters\n\t */\n\tfunction executeMultiple(ExecuteArgs[] calldata toExec) external payable {\n\t\tfor (uint256 i = 0; i != toExec.length; i++) execute(toExec[i].calls, toExec[i].signature);\n\t}\n\n\t/**\n\t * @notice  Allows executing calls if the caller itself is authorized\n\t * @dev     no need for nonce management here cause we're not dealing with sigs\n\t * @param   calls  the transaction we're executing\n\t */\n\tfunction executeBySender(Transaction[] calldata calls) external payable {\n\t\trequire(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\texecuteBatch(calls);\n\t\t// again, anti-bricking\n\t\trequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t/**\n\t * @notice  allows the contract itself to execute a batch of calls\n\t * self-calling is useful in cases like wanting to do multiple things in a tryCatchLimit\n\t * @param   calls  the calls we're executing\n\t */\n\tfunction executeBySelf(Transaction[] calldata calls) external payable {\n\t\trequire(msg.sender == address(this), 'ONLY_ACCOUNT_CAN_CALL');\n\t\texecuteBatch(calls);\n\t}\n\n\t/**\n\t * @notice  allows the contract itself to execute a single calls\n\t * self-calling is useful when you want to workaround the executeBatch()\n\t * protection of not being able to call address(0)\n\t * @param   call  the call we're executing\n\t */\n\tfunction executeBySelfSingle(Transaction calldata call) external payable {\n\t\trequire(msg.sender == address(this), 'ONLY_ACCOUNT_CAN_CALL');\n\t\texecuteCall(call.to, call.value, call.data);\n\t}\n\n\t/**\n\t * @notice  Execute a batch of transactions\n\t * @param   calls  the transaction we're executing\n\t */\n\tfunction executeBatch(Transaction[] memory calls) internal {\n\t\tuint256 len = calls.length;\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\tTransaction memory call = calls[i];\n\t\t\tif (call.to != address(0)) executeCall(call.to, call.value, call.data);\n\t\t}\n\t}\n\n\t/**\n\t * @notice  Execute a signle transaction\n\t * @dev     we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\n\t * @param   to  the address we're sending to\n\t * @param   value  the amount we're sending\n\t * @param   data  callData\n\t */\n\tfunction executeCall(address to, uint256 value, bytes memory data) internal {\n\t\tassembly {\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\tif eq(result, 0) {\n\t\t\t\tlet size := returndatasize()\n\t\t\t\tlet ptr := mload(0x40)\n\t\t\t\treturndatacopy(ptr, 0, size)\n\t\t\t\trevert(ptr, size)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice  EIP-1271 implementation\n\t * @dev     see https://eips.ethereum.org/EIPS/eip-1271\n\t * @param   hash  the signed hash\n\t * @param   signature  the signature for the signed hash\n\t * @return  bytes4  is it a success or a failure\n\t */\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\t(address recovered, bool usedUnprotected) = SignatureValidator.recoverAddrAllowUnprotected(hash, signature, false);\n\t\tif (uint256(privileges[recovered]) > (usedUnprotected ? 1 : 0)) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t/**\n\t * @notice  EIP-1155 implementation\n\t * we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function\n\t * @param   interfaceID  the interface we're signaling support for\n\t * @return  bool  do we support the interface or not\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool) {\n\t\tbool supported = interfaceID == 0x01ffc9a7 || // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\n\t\t\tinterfaceID == 0x150b7a02 || // ERC721TokenReceiver\n\t\t\tinterfaceID == 0x4e2312e0 || // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n\t\t\tinterfaceID == 0x0a417632; // used for checking whether the account is v2 or not\n\t\tif (supported) return true;\n\t\taddress payable fallbackHandler = payable(address(uint160(uint256(privileges[FALLBACK_HANDLER_SLOT]))));\n\t\tif (fallbackHandler == address(0)) return false;\n\t\treturn AmbireAccount(fallbackHandler).supportsInterface(interfaceID);\n\t}\n\n\t//\n\t// EIP-4337 implementation\n\t//\n\t// return value in case of signature failure, with no time-range.\n\t// equivalent to packSigTimeRange(true,0,0);\n\tuint256 constant internal SIG_VALIDATION_FAILED = 1;\n\t// equivalent to packSigTimeRange(false,0,0);\n\tuint256 constant internal SIG_VALIDATION_SUCCESS = 0;\n\n\t/**\n\t * @notice  EIP-4337 implementation\n\t * @dev     We have an edge case for enabling ERC-4337 in the first if statement.\n\t * If the function call is to execute, we do not perform an userOp sig validation.\n\t * We require a one time hash nonce commitment from the paymaster for the given\n\t * req. We use this to give permissions to the entry point on the fly\n\t * and enable ERC-4337\n\t * @param   op  the PackedUserOperation we're executing\n\t * @param   userOpHash  the hash we've committed to\n\t * @param   missingAccountFunds  the funds the account needs to pay\n\t * @return  uint256  0 for success, 1 for signature failure, and a uint256\n\t * packed timestamp for a future valid signature:\n\t * address aggregator, uint48 validUntil, uint48 validAfter\n\t */\n\tfunction validateUserOp(PackedUserOperation calldata op, bytes32 userOpHash, uint256 missingAccountFunds)\n\texternal payable returns (uint256)\n\t{\n\t\t// enable running executeMultiple operation through the entryPoint if\n\t\t// a paymaster sponsors it with a commitment one-time nonce.\n\t\t// two use cases:\n\t\t// 1) enable 4337 on a network by giving privileges to the entryPoint\n\t\t// 2) key recovery. If the key is lost, we cannot sign the userOp,\n\t\t// so we have to go to `execute` to trigger the recovery logic\n\t\t// Why executeMultiple but not execute?\n\t\t// executeMultiple allows us to combine recovery + fee payment calls.\n\t\t// The fee payment call will be with a signature from the new key\n\t\tif (op.callData.length >= 4 && bytes4(op.callData[0:4]) == this.executeMultiple.selector) {\n\t\t\t// Require a paymaster, otherwise this mode can be used by anyone to get the user to spend their deposit\n\t\t\t// @estimation-no-revert\n\t\t\tif (op.signature.length != 0) return SIG_VALIDATION_FAILED;\n\n\t\t\trequire(\n\t\t\t\top.paymasterAndData.length >= UserOpHelper.PAYMASTER_DATA_OFFSET &&\n\t\t\t\tbytes20(op.paymasterAndData[:UserOpHelper.PAYMASTER_ADDR_OFFSET]) != bytes20(0),\n\t\t\t\t'validateUserOp: paymaster required in execute() mode'\n\t\t\t);\n\n\t\t\t// hashing in everything except sender (nonces are scoped by sender anyway), nonce, signature\n\t\t\tuint256 targetNonce = uint256(keccak256(\n\t\t\t\tabi.encode(op.initCode, op.callData, op.accountGasLimits, op.preVerificationGas, op.gasFees, op.paymasterAndData)\n\t\t\t)) << 64;\n\n\t\t\t// @estimation-no-revert\n\t\t\tif (op.nonce != targetNonce) return SIG_VALIDATION_FAILED;\n\n\t\t\treturn SIG_VALIDATION_SUCCESS;\n\t\t}\n\n\t\trequire(privileges[msg.sender] == ENTRY_POINT_MARKER, 'validateUserOp: not from entryPoint');\n\n\t\t// @estimation\n\t\t// paying should happen even if signature validation fails\n\t\tif (missingAccountFunds > 0) {\n\t\t\t// NOTE: MAY pay more than the minimum, to deposit for future transactions\n\t\t\t(bool success,) = msg.sender.call{value : missingAccountFunds}('');\n\t\t\t// ignore failure (its EntryPoint's job to verify, not account.)\n\t\t\t(success);\n\t\t}\n\n\t\t// this is replay-safe because userOpHash is retrieved like this: keccak256(abi.encode(userOp.hash(), address(this), block.chainid))\n\t\taddress signer = SignatureValidator.recoverAddr(userOpHash, op.signature, true);\n\t\tif (privileges[signer] == bytes32(0)) return SIG_VALIDATION_FAILED;\n\n\t\treturn SIG_VALIDATION_SUCCESS;\n\t}\n\n\tfunction validateExternalSig(Transaction[] memory calls, bytes calldata signature)\n\tinternal returns(address signerKey, bool isValidSig, uint256 timestampValidAfter) {\n\t\t(bytes memory sig, ) = SignatureValidator.splitSignature(signature);\n\t\t// the address of the validator we're using for this validation\n\t\taddress validatorAddr;\n\t\t// all the data needed by the validator to execute the validation.\n\t\t// In the case of DKIMRecoverySigValidator, this is AccInfo:\n\t\t// abi.encode {string emailFrom; string emailTo; string domainName;\n\t\t// bytes dkimPubKeyModulus; bytes dkimPubKeyExponent; address secondaryKey;\n\t\t// bool acceptUnknownSelectors; uint32 waitUntilAcceptAdded;\n\t\t// uint32 waitUntilAcceptRemoved; bool acceptEmptyDKIMSig;\n\t\t// bool acceptEmptySecondSig;uint32 onlyOneSigTimelock;}\n\t\t// The struct is declared in DKIMRecoverySigValidator\n\t\tbytes memory validatorData;\n\t\t// the signature data needed by the external validator.\n\t\t// In the case of DKIMRecoverySigValidator, this is abi.encode(\n\t\t// SignatureMeta memory sigMeta, bytes memory dkimSig, bytes memory secondSig\n\t\t// ).\n\t\tbytes memory innerSig;\n\t\t// the signerKey in this case is an arbitrary value that does\n\t\t// not have any specific purpose other than representing\n\t\t// the privileges key\n\t\t(signerKey, validatorAddr, validatorData, innerSig) = abi.decode(sig, (address, address, bytes, bytes));\n\t\trequire(\n\t\t\tprivileges[signerKey] == keccak256(abi.encode(validatorAddr, validatorData)),\n\t\t\t'EXTERNAL_VALIDATION_NOT_SET'\n\t\t);\n\n\t\t// The sig validator itself should throw when a signature isn't validated successfully\n\t\t// the return value just indicates whether we want to execute the current calls\n\t\t(isValidSig, timestampValidAfter) = ExternalSigValidator(validatorAddr).validateSig(validatorData, innerSig, calls);\n\t}\n}\n"
    },
    "src/AmbireFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport './deployless/IAmbireAccount.sol';\nimport './libs/Transaction.sol';\n\n/**\n * @notice  A contract used for deploying AmbireAccount.sol\n * @dev     We use create2 to get the AmbireAccount address. It's deterministic:\n * if the same data is passed to it, the same address will pop out.\n */\ncontract AmbireFactory {\n\tevent LogDeployed(address addr, uint256 salt);\n\n\taddress public immutable allowedToDrain;\n\n\tconstructor(address allowed) {\n\t\tallowedToDrain = allowed;\n\t}\n\n\t/**\n\t * @notice  Allows anyone to deploy any contracft with a specific code/salt\n\t * @dev     This is safe because it's CREATE2 deployment\n\t * @param   code  the code to be deployed\n\t * @param   salt  the salt to shuffle the computed address\n\t * @return  address  the deployed address\n\t */\n\tfunction deploy(bytes calldata code, uint256 salt) external returns(address) {\n\t\treturn deploySafe(code, salt);\n\t}\n\n\t\n\t/**\n\t * @notice  Call this when you want to deploy the contract and execute calls\n\t * @dev     When the relayer needs to act upon an /identity/:addr/submit call, it'll either call execute on the AmbireAccount directly\n\t * if it's already deployed, or call `deployAndExecute` if the account is still counterfactual\n\t * we can't have deployAndExecuteBySender, because the sender will be the factory\n\t * @param   code  the code to be deployed\n\t * @param   salt  the salt to shuffle the computed address\n\t * @param   txns  the txns the are going to be executed\n\t * @param   signature  the signature for the txns\n\t * @return  address  the deployed address\n\t */\n\tfunction deployAndExecute(\n\t\tbytes calldata code,\n\t\tuint256 salt,\n\t\tTransaction[] calldata txns,\n\t\tbytes calldata signature\n\t) external returns (address){\n\t\taddress payable addr = payable(deploySafe(code, salt));\n\t\tIAmbireAccount(addr).execute(txns, signature);\n\t\treturn addr;\n\t}\n\n\t\n\t/**\n\t * @notice  Call this when you want to deploy the contract and call executeMultiple\n\t * @dev     when the relayer needs to act upon an /identity/:addr/submit call, \n\t * it'll either call execute on the AmbireAccount directly. If it's already\n\t * deployed, or call `deployAndExecuteMultiple` if the account is still\n\t * counterfactual but there are multiple accountOps to send\n\t * @param   code  the code to be deployed\n\t * @param   salt  the salt to shuffle the computed address\n\t * @param   toExec  [txns, signature] execute parameters\n\t * @return  address  the deployed address\n\t */\n\tfunction deployAndExecuteMultiple(\n\t\tbytes calldata code,\n\t\tuint256 salt,\n\t\tIAmbireAccount.ExecuteArgs[] calldata toExec\n\t) external returns (address){\n\t\taddress payable addr = payable(deploySafe(code, salt));\n\t\tIAmbireAccount(addr).executeMultiple(toExec);\n\t\treturn addr;\n\t}\n\n\t/**\n\t * @notice  This method can be used to withdraw stuck tokens or airdrops\n\t * @dev     Only allowedToDrain can do the call\n\t * @param   to  receiver\n\t * @param   value  how much to be sent\n\t * @param   data  if a token has airdropped, code to send it\n\t * @param   gas  maximum gas willing to spend\n\t */\n\tfunction call(address to, uint256 value, bytes calldata data, uint256 gas) external {\n\t\trequire(msg.sender == allowedToDrain, 'ONLY_AUTHORIZED');\n\t\t(bool success, bytes memory err) = to.call{ gas: gas, value: value }(data);\n\t\trequire(success, string(err));\n\t}\n\t\n\t/**\n\t * @dev     This is done to mitigate possible frontruns where, for example,\n\t * where deploying the same code/salt via deploy() would make a pending\n\t * deployAndExecute fail. The way we mitigate that is by checking if the\n\t * contract is already deployed and if so, we continue execution\n\t * @param   code  the code to be deployed\n\t * @param   salt  the salt to shuffle the computed address\n\t * @return  address  the deployed address\n\t */\n\tfunction deploySafe(bytes memory code, uint256 salt) internal returns (address) {\n\t\taddress expectedAddr = address(\n\t\t\tuint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)))))\n\t\t);\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(expectedAddr)\n\t\t}\n\t\t// If there is code at that address, we can assume it's the one we were about to deploy,\n\t\t// because of how CREATE2 and keccak256 works\n\t\tif (size == 0) {\n\t\t\taddress addr;\n\t\t\tassembly {\n\t\t\t\taddr := create2(0, add(code, 0x20), mload(code), salt)\n\t\t\t}\n\t\t\trequire(addr != address(0), 'FAILED_DEPLOYING');\n\t\t\trequire(addr == expectedAddr, 'FAILED_MATCH');\n\t\t\temit LogDeployed(addr, salt);\n\t\t}\n\t\treturn expectedAddr;\n\t}\n}\n"
    },
    "src/AmbirePaymaster.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport './deployless/IAmbireAccount.sol';\nimport './libs/erc4337/IPaymaster.sol';\nimport './libs/SignatureValidator.sol';\nimport './libs/erc4337/UserOpHelper.sol';\n\ncontract AmbirePaymaster is IPaymaster {\n\n\taddress immutable public relayer;\n\n\tconstructor(address _relayer) {\n\t\trelayer = _relayer;\n\t}\n\n\t/**\n\t * @notice  This method can be used to withdraw stuck tokens or airdrops\n\t *\n\t * @param   to  The address we're calling\n\t * @param   value  The value in the call\n\t * @param\tdata\tthe call data\n\t * @param\tgas\tthe call gas\n\t */\n\tfunction call(address to, uint256 value, bytes calldata data, uint256 gas) external payable {\n\t\trequire(msg.sender == relayer, 'call: not relayer');\n\t\t(bool success, bytes memory err) = to.call{ gas: gas, value: value }(data);\n\t\trequire(success, string(err));\n\t}\n\n\t/**\n\t * @notice  Validate user operations the paymaster has signed\n\t * We do not need to send funds to the EntryPoint because we rely on pre-existing deposit.\n\t * Requests are chain specific to prevent signature reuse.\n\t * @dev     We have two use cases for the paymaster:\n\t * - normal erc-4337. Everything is per ERC-4337 standard, the nonce is sequential.\n\t * - an executeMultiple call. If the calldata is executeMultiple, we've hardcoded\n\t * a 0 nonce. That's what's called a one-time hash nonce and its key is actually\n\t * the commitment. Check EntryPoint -> NonceManager for more information.\n\t *\n\t * @param   userOp  the UserOperation we're executing\n\t * @return  context  context is returned in the postOp and called by the\n\t * EntryPoint. But we're not using postOp is context is always emtpy\n\t * @return  validationData  This consists of:\n\t * - an aggregator address: address(uint160(validationData)). This is used\n\t * when you want an outer contract to determine whether the signature is valid.\n\t * In our case, this is always 0 (address 0) for valid signatures and\n\t * 1 (address 1) for invalid. This is what the entry point expects and\n\t * in those two cases, an outer contract is obviously not called.\n\t * - a uint48 validUntil: uint48(validationData >> 160)\n\t * A Paymaster signature can be signed at time \"x\" but delayed intentionally\n\t * until time \"y\" when a fee payment's price has dropped significantly or\n\t * some other issue. validUntil sets a time validity for the signature\n     * - a uint48 validAfter: uint48(validationData >> (48 + 160))\n\t * If the signature should be valid only after a period of time,\n\t * we tweak the validAfter property.\n\t * For more information, check EntryPoint -> _getValidationData()\n\t */\n\tfunction validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32, uint256)\n\t\texternal\n\t\tview\n\t\treturns (bytes memory context, uint256 validationData)\n\t{\n\t\t(uint48 validUntil, uint48 validAfter, bytes memory signature) = abi.decode(\n\t\t\tuserOp.paymasterAndData[UserOpHelper.PAYMASTER_DATA_OFFSET:],\n\t\t\t(uint48, uint48, bytes)\n\t\t);\n\n\t\tbytes memory callData = userOp.callData;\n\t\tbytes32 hash = keccak256(abi.encode(\n\t\t\tblock.chainid,\n\t\t\taddress(this),\n\t\t\t// entry point\n\t\t\tmsg.sender,\n\t\t\tvalidUntil,\n\t\t\tvalidAfter,\n\t\t\t// everything except paymasterAndData and signature\n\t\t\tuserOp.sender,\n\t\t\t// for the nonce we have an exception case: one-time nonces depend on paymasterAndData, which is generated by the relayer\n\t\t\t// we can't have this as part of the sig cuz we create a cyclical dep\n\t\t\t// the nonce can only be used once, so one cannot replay the gas payment\n\t\t\tcallData.length >= 4 && bytes4(userOp.callData[0:4]) == IAmbireAccount.executeMultiple.selector ? 0 : userOp.nonce,\n\t\t\tuserOp.initCode,\n\t\t\tcallData,\n\t\t\tuserOp.accountGasLimits,\n\t\t\tuserOp.preVerificationGas,\n\t\t\tuserOp.gasFees\n\t\t));\n\t\tbool isValidSig = SignatureValidator.recoverAddr(hash, signature, true) == relayer;\n\t\t// see _packValidationData: https://github.com/eth-infinitism/account-abstraction/blob/f2b09e60a92d5b3177c68d9f382912ccac19e8db/contracts/core/Helpers.sol#L73-L80\n\t\treturn (\"\", uint160(isValidSig ? 0 : 1) | (uint256(validUntil) << 160) | (uint256(validAfter) << 208));\n\t}\n\n\t/**\n\t * @notice  No-op, won't be used because we don't return a context\n\t * @param   mode  .\n\t * @param   context  .\n\t * @param   actualGasCost  .\n\t */\n\tfunction postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external {\n\t\t// No-op, won't be used because we don't return a context\n\t}\n}\n"
    },
    "src/DeployHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport './AmbireAccount.sol';\nimport './AmbireFactory.sol';\nimport './AmbirePaymaster.sol';\n\ncontract DeployHelper {\n  constructor() {\n    new AmbireAccount();\n    new AmbireFactory(0x942f9CE5D9a33a82F88D233AEb3292E680230348);\n    new AmbirePaymaster(0x39f1B4be409F2DFC8FCB84C1196537728df727f3);\n    // no need to selfdestruct because it doesn't give a refund anymore\n  }\n}\n"
    },
    "src/ExternalSigValidator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport './libs/Transaction.sol';\n\n/**\n * @title   ExternalSigValidator\n * @notice  A way to add custom recovery to AmbireAccount.\n * address accountAddr is the Ambire account address\n * bytes calldata data is all the data needed by the ExternalSigValidator.\n * It could be anything and it's validator specific.\n * bytes calldata sig is the signature we're validating. Notice its not\n * bytes32 so there could be cases where its not only the signature. It's\n * validator specific\n * uint256 nonce - the Ambire account nonce\n * Transaction[] calldata calls - the txns that are going to be executed\n * if the validation is successful\n * @dev     Not all passed properties necessarily need to be used.\n */\nabstract contract ExternalSigValidator {\n\tfunction validateSig(\n\t\tbytes calldata data,\n\t\tbytes calldata sig,\n\t\tTransaction[] calldata calls\n\t) external virtual returns (bool isValidSignature, uint256 timestampValidAfter);\n}"
    },
    "src/deployless/IAmbireAccount.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport '../libs/Transaction.sol';\n\ninterface IAmbireAccount {\n\tfunction privileges(address addr) external returns (bytes32);\n\tfunction nonce() external returns (uint);\n\n\tstruct RecoveryInfo {\n\t\taddress[] keys;\n\t\tuint timelock;\n\t}\n\tstruct ExecuteArgs {\n\t\tTransaction[] calls;\n\t\tbytes signature;\n\t}\n\n\tfunction setAddrPrivilege(address addr, bytes32 priv) external payable;\n\tfunction tryCatch(address to, uint value, bytes calldata data) external payable;\n\tfunction tryCatchLimit(address to, uint value, bytes calldata data, uint gasLimit) external payable;\n\n\tfunction execute(Transaction[] calldata txns, bytes calldata signature) external payable;\n\tfunction executeBySender(Transaction[] calldata txns) external payable;\n\tfunction executeBySelf(Transaction[] calldata txns) external payable;\n\tfunction executeMultiple(ExecuteArgs[] calldata toExec) external payable;\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4);\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/libs/Bytes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nlibrary Bytes {\n\tfunction trimToSize(bytes memory b, uint256 newLen) internal pure {\n\t\trequire(b.length > newLen, 'BytesLib: only shrinking');\n\t\tassembly {\n\t\t\tmstore(b, newLen)\n\t\t}\n\t}\n\n\t/***********************************|\n\t|        Read Bytes Functions       |\n\t|__________________________________*/\n\n\t/**\n\t * @dev Reads a bytes32 value from a position in a byte array.\n\t * @param b Byte array containing a bytes32 value.\n\t * @param index Index in byte array of bytes32 value.\n\t * @return result bytes32 value from byte array.\n\t */\n\tfunction readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\t\t// Arrays are prefixed by a 256 bit length parameter\n\t\tindex += 32;\n\n\t\trequire(b.length >= index, 'BytesLib: length');\n\n\t\t// Read the bytes32 from array memory\n\t\tassembly {\n\t\t\tresult := mload(add(b, index))\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    },
    "src/libs/SignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport './Bytes.sol';\n\ninterface IERC1271Wallet {\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n\nlibrary SignatureValidator {\n\tusing Bytes for bytes;\n\n\tenum SignatureMode {\n\t\t// the first mode Unprotected is used in combination with EIP-1271 signature verification to do\n\t\t// EIP-712 verifications, as well as \"Ethereum signed message:\" message verifications\n\t\t// The caveat with this is that we need to ensure that the signer key used for it isn't reused, or the message body\n\t\t// itself contains context about the wallet (such as it's address)\n\t\t// We do this, rather than applying the prefix on-chain, because if we do you won't be able to see the message\n\t\t// when signing on a hardware wallet (you'll only see the hash) - since `isValidSignature` can only receive the hash -\n\t\t// if the prefix is applied on-chain you can never match it - it's hash(prefix+hash(msg)) vs hash(prefix+msg)\n\t\t// As for transactions (`execute()`), those can be signed with any of the modes\n\t\t// Otherwise, if it's reused, we MUST use `Standard` mode which always wraps the final digest hash, but unfortnately this means\n\t\t// you can't preview the full message when signing on a HW wallet\n\t\tUnprotected,\n\t\tStandard,\n\t\tSmartWallet,\n\t\tSpoof,\n\t\tSchnorr,\n\t\tMultisig,\n\t\t// WARNING: Signature modes should not be more than 26 as the \"v\"\n\t\t// value for standard ecrecover is 27/28\n\t\t// WARNING: must always be last\n\t\tLastUnused\n\t}\n\n\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n\tbytes4 internal constant ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\n\t// secp256k1 group order\n\tuint256 internal constant Q = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n\n\tfunction splitSignature(bytes memory sig) internal pure returns (bytes memory, uint8) {\n\t\tuint8 modeRaw;\n\t\tunchecked {\n\t\t\tmodeRaw = uint8(sig[sig.length - 1]);\n\t\t}\n\t\tsig.trimToSize(sig.length - 1);\n\t\treturn (sig, modeRaw);\n\t}\n\n\tfunction recoverAddr(bytes32 hash, bytes memory sig, bool allowSpoofing) internal view returns (address) {\n\t\t(address recovered, bool usedUnprotected) = recoverAddrAllowUnprotected(hash, sig, allowSpoofing);\n\t\trequire(!usedUnprotected, 'SV_USED_UNBOUND');\n\t\treturn recovered;\n\t}\n\n\tfunction recoverAddrAllowUnprotected(bytes32 hash, bytes memory sig, bool allowSpoofing) internal view returns (address, bool) {\n\t\trequire(sig.length != 0, 'SV_SIGLEN');\n\n\t\tuint8 modeRaw;\n\t\tunchecked {\n\t\t\tmodeRaw = uint8(sig[sig.length - 1]);\n\t\t}\n\t\t// Ensure we're in bounds for mode; Solidity does this as well but it will just silently blow up rather than showing a decent error\n\t\tif (modeRaw >= uint8(SignatureMode.LastUnused)) {\n\t\t\tif (sig.length == 65) modeRaw = uint8(SignatureMode.Unprotected);\n\t\t\telse revert('SV_SIGMODE');\n\t\t}\n\t\tSignatureMode mode = SignatureMode(modeRaw);\n\n\t\t// the address of the key we are gonna be returning\n\t\taddress signerKey;\n\n\t\t// wrap in the EIP712 wrapping if it's not unbound\n\t\t// multisig gets an exception because each inner sig will have to apply this logic\n\t\t// @TODO should spoofing be removed from this?\n\t\tbool isUnprotected = mode == SignatureMode.Unprotected || mode == SignatureMode.Multisig;\n\t\tif (!isUnprotected) {\n\t\t\tbytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(\n\t\t\t\tkeccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)'),\n\t\t\t\tkeccak256(bytes('Ambire')),\n\t\t\t\tkeccak256(bytes('1')),\n\t\t\t\tblock.chainid,\n\t\t\t\taddress(this),\n\t\t\t\tbytes32(0)\n\t\t\t));\n\t\t\thash = keccak256(abi.encodePacked(\n\t\t\t\t'\\x19\\x01',\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(abi.encode(\n\t\t\t\t\tkeccak256(bytes('AmbireOperation(address account,bytes32 hash)')),\n\t\t\t\t\taddress(this),\n\t\t\t\t\thash\n\t\t\t\t))\n\t\t\t));\n\t\t}\n\n\t\t// {r}{s}{v}{mode}\n\t\tif (mode == SignatureMode.Unprotected || mode == SignatureMode.Standard) {\n\t\t\trequire(sig.length == 65 || sig.length == 66, 'SV_LEN');\n\t\t\tbytes32 r = sig.readBytes32(0);\n\t\t\tbytes32 s = sig.readBytes32(32);\n\t\t\tuint8 v = uint8(sig[64]);\n\t\t\tsignerKey = ecrecover(hash, v, r, s);\n\t\t// {sig}{verifier}{mode}\n\t\t} else if (mode == SignatureMode.Schnorr) {\n\t\t\t// Based on https://hackmd.io/@nZ-twauPRISEa6G9zg3XRw/SyjJzSLt9\n\t\t\t// You can use this library to produce signatures: https://github.com/borislav-itskov/schnorrkel.js\n\t\t\t// px := public key x-coord\n\t\t\t// e := schnorr signature challenge\n\t\t\t// s := schnorr signature\n\t\t\t// parity := public key y-coord parity (27 or 28)\n\t\t\t// last uint8 is for the Ambire sig mode - it's ignored\n\t\t\tsig.trimToSize(sig.length - 1);\n\t\t\t(bytes32 px, bytes32 e, bytes32 s, uint8 parity) = abi.decode(sig, (bytes32, bytes32, bytes32, uint8));\n\t\t\t// ecrecover = (m, v, r, s);\n\t\t\tbytes32 sp = bytes32(Q - mulmod(uint256(s), uint256(px), Q));\n\t\t\tbytes32 ep = bytes32(Q - mulmod(uint256(e), uint256(px), Q));\n\n\t\t\trequire(sp != bytes32(Q));\n\t\t\t// the ecrecover precompile implementation checks that the `r` and `s`\n\t\t\t// inputs are non-zero (in this case, `px` and `ep`), thus we don't need to\n\t\t\t// check if they're zero.\n\t\t\taddress R = ecrecover(sp, parity, px, ep);\n\t\t\trequire(R != address(0), 'SV_ZERO_SIG');\n\t\t\trequire(e == keccak256(abi.encodePacked(R, uint8(parity), px, hash)), 'SV_SCHNORR_FAILED');\n\t\t\tsignerKey = address(uint160(uint256(keccak256(abi.encodePacked('SCHNORR', px)))));\n\t\t} else if (mode == SignatureMode.Multisig) {\n\t\t\tsig.trimToSize(sig.length - 1);\n\t\t\tbytes[] memory signatures = abi.decode(sig, (bytes[]));\n\t\t\t// since we're in a multisig, we care if any of the inner sigs are unbound\n\t\t\tisUnprotected = false;\n\t\t\tfor (uint256 i = 0; i != signatures.length; i++) {\n\t\t\t\t(address inner, bool isInnerUnprotected) = recoverAddrAllowUnprotected(hash, signatures[i], false);\n\t\t\t\tif (isInnerUnprotected) isUnprotected = true;\n\t\t\t\tsignerKey = address(\n\t\t\t\t\tuint160(uint256(keccak256(abi.encodePacked(signerKey, inner))))\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (mode == SignatureMode.SmartWallet) {\n\t\t\t// 32 bytes for the addr, 1 byte for the type = 33\n\t\t\trequire(sig.length > 33, 'SV_LEN_WALLET');\n\t\t\tuint256 newLen;\n\t\t\tunchecked {\n\t\t\t\tnewLen = sig.length - 33;\n\t\t\t}\n\t\t\tIERC1271Wallet wallet = IERC1271Wallet(address(uint160(uint256(sig.readBytes32(newLen)))));\n\t\t\tsig.trimToSize(newLen);\n\t\t\trequire(ERC1271_MAGICVALUE_BYTES32 == wallet.isValidSignature(hash, sig), 'SV_WALLET_INVALID');\n\t\t\tsignerKey = address(wallet);\n\t\t// {address}{mode}; the spoof mode is used when simulating calls\n\t\t} else if (mode == SignatureMode.Spoof && allowSpoofing) {\n\t\t\t// This is safe cause it's specifically intended for spoofing sigs in simulation conditions, where tx.origin can be controlled\n\t\t\t// We did not choose 0x00..00 because in future network upgrades tx.origin may be nerfed or there may be edge cases in which\n\t\t\t// it is zero, such as native account abstraction\n\t\t\t// slither-disable-next-line tx-origin\n\t\t\trequire(tx.origin == address(1) || tx.origin == address(6969), 'SV_SPOOF_ORIGIN');\n\t\t\trequire(sig.length == 33, 'SV_SPOOF_LEN');\n\t\t\tsig.trimToSize(32);\n\t\t\t// To simulate the gas usage; check is just to silence unused warning\n\t\t\trequire(ecrecover(0, 0, 0, 0) != address(6969));\n\t\t\tsignerKey = abi.decode(sig, (address));\n\t\t} else {\n\t\t\trevert('SV_TYPE');\n\t\t}\n\t\trequire(signerKey != address(0), 'SV_ZERO_SIG');\n\t\treturn (signerKey, isUnprotected);\n\t}\n}\n"
    },
    "src/libs/Transaction.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\n// Transaction structure\n// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig\n// @dev a better name for this would be `Call`, but we are keeping `Transaction` for backwards compatibility\nstruct Transaction {\n    address to;\n    uint256 value;\n    bytes data;\n}\n"
    },
    "src/libs/erc4337/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n\n    enum PostOpMode {\n        opSucceeded, // user op succeeded\n        opReverted, // user op reverted. still has to pay for gas.\n        postOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\n    }\n\n    /**\n     * payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp the user operation\n     * @param userOpHash hash of the user's request data.\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\n     * @return context value to send to a postOp\n     *      zero length to signify postOp is not required.\n     * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * post-operation handler.\n     * Must verify sender is the entryPoint\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\n}\n"
    },
    "src/libs/erc4337/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n  address sender;\n  uint256 nonce;\n  bytes initCode;\n  bytes callData;\n  // callGasLimit + verificationGasLimit\n  bytes32 accountGasLimits;\n  uint256 preVerificationGas;\n  // maxFeePerGas + maxPriorityFeePerGas\n  bytes32 gasFees;\n  bytes paymasterAndData;\n  bytes signature;\n}\n"
    },
    "src/libs/erc4337/UserOpHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nlibrary UserOpHelper {\n\tuint256 public constant PAYMASTER_ADDR_OFFSET = 20;\n\n  // 52 = 20 address + 16 paymasterVerificationGasLimit + 16 paymasterPostOpGasLimit\n\tuint256 public constant PAYMASTER_DATA_OFFSET = 52;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": true,
    "libraries": {}
  }
}