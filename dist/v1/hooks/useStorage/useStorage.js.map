{"version":3,"file":"useStorage.js","sourceRoot":"","sources":["../../../../v1/hooks/useStorage/useStorage.ts"],"names":[],"mappings":";;AAiBA,6BA0DC;AA3ED,iCAA6C;AAI7C,MAAM,cAAc,GAAG,CAAY,IAAe,EAAa,EAAE,CAAC,IAAI,CAAA;AAEtE;;;;;;;;;;GAUG;AACH,SAAwB,UAAU,CAAY,EAC5C,OAAO,EACP,GAAG,EACH,YAAY,GAAG,IAAI,EACnB,eAAe,GAAG,KAAK;AACvB,wDAAwD;AACxD,OAAO,GAAG,cAAc,EACG;IAC3B,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,IAAA,gBAAQ,EAAmB,GAAG,EAAE;QAClD,kFAAkF;QAClF,qEAAqE;QACrE,sCAAsC;QACtC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC;YAAE,OAAO,OAAO,CAAC,YAAY,CAAC,CAAA;QAEvD,qEAAqE;QACrE,sCAAsC;QACtC,IAAI,eAAe;YAAE,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAA;QAEzD,mDAAmD;QACnD,8DAA8D;QAC9D,IAAI,UAAU,CAAA;QAEd,IAAI,CAAC;YACH,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAE,CAAC,CAAA;QAChD,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACX,OAAO,CAAC,KAAK,CAAC,2CAA2C,GAAG,EAAE,EAAE,CAAC,CAAC,CAAA;YAElE,UAAU,GAAG,YAAY,CAAA;QAC3B,CAAC;QAED,OAAO,OAAO,CAAC,UAAU,CAAC,CAAA;IAC5B,CAAC,CAAC,CAAA;IAEF,MAAM,OAAO,GAAG,IAAA,mBAAW,EACzB,CAAC,KAAuB,EAAQ,EAAE;QAChC,GAAG,CAAC,CAAC,SAAc,EAAE,EAAE;YACrB,MAAM,SAAS,GAAG,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAA;YAExE,IAAI,eAAe,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,CAAC;gBACrD,MAAM,IAAI,KAAK,CACb,6DAA6D,OAAO,SAAS,GAAG,CACjF,CAAA;YACH,CAAC;YAED,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,eAAe,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAA;YAE7E,OAAO,SAAS,CAAA;QAClB,CAAC,CAAC,CAAA;IACJ,CAAC,EACD,CAAC,OAAO,EAAE,GAAG,EAAE,eAAe,CAAC,CAChC,CAAA;IAED,MAAM,UAAU,GAAG,IAAA,mBAAW,EAAC,GAAS,EAAE;QACxC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;QACvB,GAAG,CAAC,IAAI,CAAC,CAAA;IACX,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAA;IAElB,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE,UAAU,CAAC,CAAA;AACpC,CAAC","sourcesContent":["import { useCallback, useState } from 'react'\n\nimport { UseStorageProps, UseStorageReturnType } from './types'\n\nconst setInitDefault = <ValueType>(item: ValueType): ValueType => item\n\n/**\n * The main role of this hook is to hide the Storage provider we are using under the hood (AsyncStorage/localStorage).\n * This will allow us to share code between mobile/web.\n *\n * @param storage - Object implementing Storage interface. For instance, localStorage.\n * @param key - Storage item key name.\n * @param defaultValue - Default value to be used, in the case the Storage item is not set. If we don't pass it - it will default to null.\n * @param isStringStorage - Flag for disabling parsing and item stringifying. If it's enabled, we will treat whatever is in the storage as a string.\n * @param setInit - In some advanced cases, we need to perform additional logic for setting the defaultValue, based on the Storage item parsed value.\n * setInit function will provide us quick access to the parsed Storage item and based on its value we can return the needed default/init value of the hook.\n */\nexport default function useStorage<ValueType>({\n  storage,\n  key,\n  defaultValue = null,\n  isStringStorage = false,\n  // @ts-ignore FIXME: Figure out why TypeScript complains\n  setInit = setInitDefault\n}: UseStorageProps<ValueType>): UseStorageReturnType<ValueType | null> {\n  const [item, set] = useState<ValueType | null>(() => {\n    // In case the item is not set in the storage, we just fall back to `defaultValue`\n    // @ts-ignore FIXME: figure out how to use better type for `setInit`,\n    // so that TypeScript doesn't complain\n    if (!storage.getItem(key)) return setInit(defaultValue)\n\n    // @ts-ignore FIXME: figure out how to use better type for `setInit`,\n    // so that TypeScript doesn't complain\n    if (isStringStorage) return setInit(storage.getItem(key))\n\n    // Here we are going to keep the parsed item value.\n    // If the parsing failed, we just fall back to `defaultValue`.\n    let parsedItem\n\n    try {\n      parsedItem = JSON.parse(storage.getItem(key)!)\n    } catch (e) {\n      console.error(`Storage item parsing failure. Item key: ${key}`, e)\n\n      parsedItem = defaultValue\n    }\n\n    return setInit(parsedItem)\n  })\n\n  const setItem = useCallback(\n    (value: ValueType | null): void => {\n      set((prevState: any) => {\n        const itemValue = typeof value === 'function' ? value(prevState) : value\n\n        if (isStringStorage && typeof itemValue !== 'string') {\n          throw new Error(\n            `Wrong item type. We expect a string to be passed, but got ${typeof itemValue}!`\n          )\n        }\n\n        storage.setItem(key, isStringStorage ? itemValue : JSON.stringify(itemValue))\n\n        return itemValue\n      })\n    },\n    [storage, key, isStringStorage]\n  )\n\n  const removeItem = useCallback((): void => {\n    storage.removeItem(key)\n    set(null)\n  }, [storage, key])\n\n  return [item, setItem, removeItem]\n}\n"]}