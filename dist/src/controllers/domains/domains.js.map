{"version":3,"file":"domains.js","sourceRoot":"","sources":["../../../../src/controllers/domains/domains.ts"],"names":[],"mappings":"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","sourcesContent":["import { getAddress, isAddress } from 'ethers'\n\nimport { RPCProviders } from '../../interfaces/provider'\nimport { reverseLookupEns } from '../../services/ensDomains'\nimport EventEmitter from '../eventEmitter/eventEmitter'\n\ninterface Domains {\n  [address: string]: {\n    ens: string | null\n    savedAt: number\n  }\n}\n\n// 15 minutes\nconst PERSIST_DOMAIN_FOR_IN_MS = 15 * 60 * 1000\n\n/**\n * Domains controller- responsible for handling the reverse lookup of addresses to ENS names.\n * Resolved names are saved in `domains` for a short period of time(15 minutes) to avoid unnecessary lookups.\n */\nexport class DomainsController extends EventEmitter {\n  #providers: RPCProviders = {}\n\n  domains: Domains = {}\n\n  loadingAddresses: string[] = []\n\n  constructor(providers: RPCProviders) {\n    super()\n    this.#providers = providers\n  }\n\n  async batchReverseLookup(addresses: string[]) {\n    const filteredAddresses = addresses.filter((address) => isAddress(address))\n    await Promise.all(filteredAddresses.map((address) => this.reverseLookup(address, false)))\n\n    this.emitUpdate()\n  }\n\n  /**\n   *Saves an already resolved ENS name for an address.\n   */\n  saveResolvedReverseLookup({\n    address,\n    name,\n    type\n  }: {\n    address: string\n    name: string\n    type: 'ens'\n  }) {\n    const checksummedAddress = getAddress(address)\n    const { ens: oldEns } = this.domains[checksummedAddress] || { ens: null }\n\n    this.domains[checksummedAddress] = {\n      ens: type === 'ens' ? name : oldEns,\n      savedAt: Date.now()\n    }\n    this.emitUpdate()\n  }\n\n  /**\n   * Resolves the ENS names for an address if such exist.\n   */\n  async reverseLookup(address: string, emitUpdate = true) {\n    if (!('1' in this.#providers)) {\n      this.emitError({\n        error: new Error('domains.reverseLookup: Ethereum provider is not available'),\n        message: 'The RPC provider for Ethereum is not available.',\n        level: 'major'\n      })\n      return\n    }\n    const checksummedAddress = getAddress(address)\n    const isAlreadyResolved = !!this.domains[checksummedAddress]\n    const isExpired =\n      isAlreadyResolved &&\n      Date.now() - this.domains[checksummedAddress].savedAt > PERSIST_DOMAIN_FOR_IN_MS\n\n    if ((isAlreadyResolved && !isExpired) || this.loadingAddresses.includes(checksummedAddress))\n      return\n\n    this.loadingAddresses.push(checksummedAddress)\n    this.emitUpdate()\n\n    let ensName = null\n\n    try {\n      ensName = (await reverseLookupEns(checksummedAddress, this.#providers['1'])) || null\n    } catch (e) {\n      console.error('ENS reverse lookup unexpected error', e)\n    }\n\n    this.domains[checksummedAddress] = {\n      ens: ensName,\n      savedAt: Date.now()\n    }\n\n    this.loadingAddresses = this.loadingAddresses.filter(\n      (loadingAddress) => loadingAddress !== checksummedAddress\n    )\n\n    if (emitUpdate) this.emitUpdate()\n  }\n}\n"]}