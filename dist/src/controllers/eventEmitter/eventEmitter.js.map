{"version":3,"file":"eventEmitter.js","sourceRoot":"","sources":["../../../../src/controllers/eventEmitter/eventEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-syntax */\nimport wait from '../../utils/wait'\n\nconst LIMIT_ON_THE_NUMBER_OF_ERRORS = 100\n\nexport type ErrorRef = {\n  // user-friendly message, ideally containing call to action\n  message: string\n  // error level, used for filtering\n  level: 'fatal' | 'major' | 'minor' | 'silent'\n  // error containing technical details and stack trace\n  error: Error\n}\n\nexport type Statuses<T extends string> = {\n  [key in T]: 'INITIAL' | 'LOADING' | 'SUCCESS' | 'ERROR'\n}\n\nexport default class EventEmitter {\n  #callbacksWithId: {\n    id: string | null\n    cb: (forceEmit?: true) => void\n  }[] = []\n\n  #callbacks: ((forceEmit?: true) => void)[] = []\n\n  #errorCallbacksWithId: {\n    id: string | null\n    cb: (error: ErrorRef) => void\n  }[] = []\n\n  #errorCallbacks: ((error: ErrorRef) => void)[] = []\n\n  #errors: ErrorRef[] = []\n\n  statuses: Statuses<string> = {}\n\n  get onUpdateIds() {\n    return this.#callbacksWithId.map((item) => item.id)\n  }\n\n  get onErrorIds() {\n    return this.#errorCallbacksWithId.map((item) => item.id)\n  }\n\n  // called emittedErrors and not just errors because some of the other controllers\n  // that extend this one have errors defined already\n  get emittedErrors() {\n    return this.#errors\n  }\n\n  /**\n   * Using this function to emit an update bypasses both background and React batching,\n   * ensuring that the state update is immediately applied at the application level (React/Extension).\n   *\n   * This is particularly handy when multiple status flags are being updated rapidly.\n   * Without the `forceEmitUpdate` option, the application will only render the very first and last status updates,\n   * batching the ones in between.\n   */\n  async forceEmitUpdate() {\n    await wait(1)\n    // eslint-disable-next-line no-restricted-syntax\n    for (const i of this.#callbacksWithId) i.cb(true)\n    // eslint-disable-next-line no-restricted-syntax\n    for (const cb of this.#callbacks) cb(true)\n  }\n\n  protected emitUpdate() {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const i of this.#callbacksWithId) i.cb()\n    // eslint-disable-next-line no-restricted-syntax\n    for (const cb of this.#callbacks) cb()\n  }\n\n  protected emitError(error: ErrorRef) {\n    this.#errors.push(error)\n    this.#trimErrorsIfNeeded()\n    console.log(\n      `[Ð•mitted error in controller ${this.constructor.name}] ${error.message}`,\n      this.#errors\n    )\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const i of this.#errorCallbacksWithId) i.cb(error)\n    // eslint-disable-next-line no-restricted-syntax\n    for (const cb of this.#errorCallbacks) cb(error)\n  }\n\n  protected async withStatus(\n    callName: string,\n    fn: Function,\n    allowConcurrentActions = false,\n    // Silence this error in prod to avoid displaying wired error messages.\n    // The only benefit of displaying it is for devs to see when an action is dispatched twice.\n    // TODO: If this happens on PROD, ideally we should get an error report somehow somewhere.\n    errorLevel: ErrorRef['level'] = process.env.APP_ENV === 'production' &&\n    process.env.IS_TESTING !== 'true'\n      ? 'silent'\n      : 'minor'\n  ) {\n    const someStatusIsLoading = Object.values(this.statuses).some((status) => status !== 'INITIAL')\n\n    if (!this.statuses[callName]) {\n      console.error(`${callName} is not defined in \"statuses\".`)\n    }\n\n    // By default, concurrent actions are disallowed to maintain consistency, particularly within sub-controllers where\n    // simultaneous actions can lead to unintended side effects. The 'allowConcurrentActions' flag is provided to enable\n    // concurrent execution at the main controller level. This is useful when multiple actions need to modify the state\n    // of different sub-controllers simultaneously.\n    if ((someStatusIsLoading && !allowConcurrentActions) || this.statuses[callName] !== 'INITIAL') {\n      this.emitError({\n        level: errorLevel,\n        message: `Please wait for the completion of the previous action before initiating another one.', ${callName}`,\n        error: new Error(\n          'Another function is already being handled by withStatus refrain from invoking a second function.'\n        )\n      })\n\n      return\n    }\n\n    this.statuses[callName] = 'LOADING'\n    await this.forceEmitUpdate()\n\n    try {\n      await fn()\n\n      this.statuses[callName] = 'SUCCESS'\n      await this.forceEmitUpdate()\n    } catch (error: any) {\n      this.statuses[callName] = 'ERROR'\n      if ('message' in error && 'level' in error && 'error' in error) {\n        this.emitError(error)\n\n        // Sometimes we don't want to show an error message to the user. For example, if the user cancels a request\n        // we don't want to go through the SUCCESS state, but we also don't want to show an error message.\n      } else if (error?.message) {\n        this.emitError({\n          message: error?.message || 'An unexpected error occurred',\n          level: 'major',\n          error\n        })\n      }\n      await this.forceEmitUpdate()\n    }\n\n    this.statuses[callName] = 'INITIAL'\n    await this.forceEmitUpdate()\n  }\n\n  // Prevents memory leaks and storing huge amount of errors\n  #trimErrorsIfNeeded() {\n    if (this.#errors.length > LIMIT_ON_THE_NUMBER_OF_ERRORS) {\n      const excessErrors = this.#errors.length - LIMIT_ON_THE_NUMBER_OF_ERRORS\n      this.#errors = this.#errors.slice(excessErrors)\n    }\n  }\n\n  // returns an unsub function\n  onUpdate(cb: (forceUpdate?: boolean) => void, id?: string): () => void {\n    if (id) {\n      this.#callbacksWithId.push({ id, cb })\n    } else {\n      this.#callbacks.push(cb)\n    }\n\n    return () => {\n      if (id) {\n        this.#callbacksWithId = this.#callbacksWithId.filter(\n          (callbackItem) => callbackItem.id !== id\n        )\n      } else {\n        this.#callbacks.splice(this.#callbacks.indexOf(cb), 1)\n      }\n    }\n  }\n\n  // returns an unsub function for error events\n  onError(cb: (error: ErrorRef) => void, id?: string): () => void {\n    if (id) {\n      this.#errorCallbacksWithId.push({ id, cb })\n    } else {\n      this.#errorCallbacks.push(cb)\n    }\n\n    return () => {\n      if (id) {\n        this.#errorCallbacksWithId = this.#errorCallbacksWithId.filter(\n          (callbackItem) => callbackItem.id !== id\n        )\n      } else {\n        this.#errorCallbacks.splice(this.#errorCallbacks.indexOf(cb), 1)\n      }\n    }\n  }\n\n  toJSON() {\n    return {\n      ...this,\n      emittedErrors: this.emittedErrors // includes the getter in the stringified instance\n    }\n  }\n}\n"]}