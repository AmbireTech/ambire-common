{"version":3,"file":"accounts.js","sourceRoot":"","sources":["../../../../src/controllers/accounts/accounts.ts"],"names":[],"mappings":"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","sourcesContent":["import { getAddress, isAddress } from 'ethers'\n\nimport {\n  Account,\n  AccountOnchainState,\n  AccountPreferences,\n  AccountStates\n} from '../../interfaces/account'\nimport { getUniqueAccountsArray } from '../../libs/account/account'\nimport { getAccountState } from '../../libs/accountState/accountState'\nimport EventEmitter, { Statuses } from '../eventEmitter/eventEmitter'\nimport { NetworksController } from '../networks/networks'\nimport { ProvidersController } from '../providers/providers'\nimport { StorageController } from '../storage/storage'\n\nconst STATUS_WRAPPED_METHODS = {\n  selectAccount: 'INITIAL',\n  updateAccountPreferences: 'INITIAL',\n  addAccounts: 'INITIAL'\n} as const\n\nexport class AccountsController extends EventEmitter {\n  #storage: StorageController\n\n  #networks: NetworksController\n\n  #providers: ProvidersController\n\n  accounts: Account[] = []\n\n  accountStates: AccountStates = {}\n\n  accountStatesLoadingState: {\n    [chainId: string]: boolean\n  } = {}\n\n  statuses: Statuses<keyof typeof STATUS_WRAPPED_METHODS> = STATUS_WRAPPED_METHODS\n\n  #onAddAccounts: (accounts: Account[]) => void\n\n  #updateProviderIsWorking: (chainId: bigint, isWorking: boolean) => void\n\n  #onAccountStateUpdate: () => void\n\n  // Holds the initial load promise, so that one can wait until it completes\n  initialLoadPromise: Promise<void>\n\n  constructor(\n    storage: StorageController,\n    providers: ProvidersController,\n    networks: NetworksController,\n    onAddAccounts: (accounts: Account[]) => void,\n    updateProviderIsWorking: (chainId: bigint, isWorking: boolean) => void,\n    onAccountStateUpdate: () => void\n  ) {\n    super()\n    this.#storage = storage\n    this.#providers = providers\n    this.#networks = networks\n    this.#onAddAccounts = onAddAccounts\n    this.#updateProviderIsWorking = updateProviderIsWorking\n    this.#onAccountStateUpdate = onAccountStateUpdate\n\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.initialLoadPromise = this.#load()\n  }\n\n  async #load() {\n    await this.#networks.initialLoadPromise\n    await this.#providers.initialLoadPromise\n    const accounts = await this.#storage.get('accounts', [])\n    this.accounts = getUniqueAccountsArray(accounts)\n\n    // Emit an update before updating account states as the first state update may take some time\n    this.emitUpdate()\n    // Don't await this. Networks should update one by one\n    // NOTE: YOU MUST USE waitForAccountsCtrlFirstLoad IN TESTS\n    // TO ENSURE ACCOUNT STATE IS LOADED\n    this.#updateAccountStates(this.accounts)\n  }\n\n  async updateAccountStates(blockTag: string | number = 'latest', networks: bigint[] = []) {\n    await this.#updateAccountStates(this.accounts, blockTag, networks)\n  }\n\n  async updateAccountState(\n    accountAddr: Account['addr'],\n    blockTag: 'pending' | 'latest' = 'latest',\n    networks: bigint[] = []\n  ) {\n    const accountData = this.accounts.find((account) => account.addr === accountAddr)\n\n    if (!accountData) return\n\n    await this.#updateAccountStates([accountData], blockTag, networks)\n  }\n\n  async #updateAccountStates(\n    accounts: Account[],\n    blockTag: string | number = 'latest',\n    updateOnlyNetworksWithIds: bigint[] = []\n  ) {\n    // if any, update the account state only for the passed networks; else - all\n    const updateOnlyPassedNetworks = updateOnlyNetworksWithIds.length\n    const networksToUpdate = this.#networks.networks.filter((network) => {\n      if (this.accountStatesLoadingState[network.chainId.toString()]) return false\n      if (!updateOnlyPassedNetworks) return true\n\n      return updateOnlyNetworksWithIds.includes(network.chainId)\n    })\n\n    networksToUpdate.forEach((network) => {\n      this.accountStatesLoadingState[network.chainId.toString()] = true\n    })\n    this.emitUpdate()\n\n    await Promise.all(\n      networksToUpdate.map(async (network) => {\n        try {\n          const networkAccountStates = await getAccountState(\n            this.#providers.providers[network.chainId.toString()],\n            network,\n            accounts,\n            blockTag\n          )\n\n          this.#updateProviderIsWorking(network.chainId, true)\n\n          networkAccountStates.forEach((accountState) => {\n            const addr = accountState.accountAddr\n\n            if (!this.accountStates[addr]) {\n              this.accountStates[addr] = {}\n            }\n\n            this.accountStates[addr][network.chainId.toString()] = accountState\n          })\n        } catch (err) {\n          console.error(`account state update error for ${network.name}: `, err)\n          this.#updateProviderIsWorking(network.chainId, false)\n        } finally {\n          this.accountStatesLoadingState[network.chainId.toString()] = false\n        }\n        this.emitUpdate()\n      })\n    )\n\n    this.#onAccountStateUpdate()\n  }\n\n  async #addAccounts(accounts: Account[] = []) {\n    if (!accounts.length) return\n    // eslint-disable-next-line no-param-reassign\n    accounts = accounts.map((a) => ({ ...a, addr: getAddress(a.addr) }))\n    const alreadyAddedAddressSet = new Set(this.accounts.map((account) => account.addr))\n    const newAccountsNotAddedYet = accounts.filter((acc) => !alreadyAddedAddressSet.has(acc.addr))\n    const newAccountsAlreadyAdded = accounts.filter((acc) => alreadyAddedAddressSet.has(acc.addr))\n\n    const nextAccounts = [\n      ...this.accounts.map((acc) => ({\n        ...acc,\n        // reset the `newlyCreated` state for all already added accounts\n        newlyCreated: false,\n        // reset the `newlyAdded` state for all accounts added on prev sessions\n        newlyAdded: false,\n        // Merge the existing and new associated keys for the account (if the\n        // account was already imported). This ensures up-to-date keys,\n        // considering changes post-import (associated keys of the smart\n        // accounts can change) or incomplete initial data (during the initial\n        // import, not all associated keys could have been fetched (for privacy).\n        associatedKeys: Array.from(\n          new Set([\n            ...acc.associatedKeys,\n            ...(newAccountsAlreadyAdded.find((x) => x.addr === acc.addr)?.associatedKeys || [])\n          ])\n        )\n      })),\n      ...newAccountsNotAddedYet.map((a) => ({ ...a, newlyAdded: true }))\n    ]\n\n    this.accounts = getUniqueAccountsArray(nextAccounts)\n    await this.#storage.set('accounts', this.accounts)\n\n    this.#onAddAccounts(accounts)\n\n    // update the state of new accounts. Otherwise, the user needs to restart his extension\n    this.#updateAccountStates(newAccountsNotAddedYet)\n\n    this.emitUpdate()\n  }\n\n  async addAccounts(accounts: Account[] = []) {\n    await this.withStatus('addAccounts', async () => this.#addAccounts(accounts), true)\n  }\n\n  removeAccountData(address: Account['addr']) {\n    this.accounts = this.accounts.filter((acc) => acc.addr !== address)\n\n    delete this.accountStates[address]\n\n    this.#storage.set('accounts', this.accounts)\n    this.emitUpdate()\n  }\n\n  async updateAccountPreferences(accounts: { addr: string; preferences: AccountPreferences }[]) {\n    await this.withStatus(\n      'updateAccountPreferences',\n      async () => this.#updateAccountPreferences(accounts),\n      true\n    )\n  }\n\n  async #updateAccountPreferences(accounts: { addr: string; preferences: AccountPreferences }[]) {\n    this.accounts = this.accounts.map((acc) => {\n      const account = accounts.find((a) => a.addr === acc.addr)\n      if (!account) return acc\n      if (isAddress(account.preferences.pfp)) {\n        account.preferences.pfp = getAddress(account.preferences.pfp)\n      }\n      return { ...acc, preferences: account.preferences }\n    })\n\n    await this.#storage.set('accounts', this.accounts)\n    this.emitUpdate()\n  }\n\n  get areAccountStatesLoading() {\n    return Object.values(this.accountStatesLoadingState).some((isLoading) => isLoading)\n  }\n\n  // Get the account states or in the rare case of it being undefined,\n  // fetch it.\n  // This is a precaution method as we had bugs in the past where we assumed\n  // the account state to be fetched only for it to haven't been.\n  // This ensures production doesn't blow up and it 99.9% of cases it\n  // should not call the promise\n  async getOrFetchAccountStates(addr: string): Promise<{ [chainId: string]: AccountOnchainState }> {\n    if (!this.accountStates[addr]) await this.updateAccountState(addr, 'latest')\n    return this.accountStates[addr]\n  }\n\n  // Get the account state or in the rare case of it being undefined,\n  // fetch it.\n  // This is a precaution method as we had bugs in the past where we assumed\n  // the account state to be fetched only for it to haven't been.\n  // This ensures production doesn't blow up and it 99.9% of cases it\n  // should not call the promise\n  async getOrFetchAccountOnChainState(addr: string, chainId: bigint): Promise<AccountOnchainState> {\n    if (!this.accountStates[addr][chainId.toString()])\n      await this.updateAccountState(addr, 'latest', [chainId])\n\n    return this.accountStates[addr][chainId.toString()]\n  }\n\n  resetAccountsNewlyAddedState() {\n    this.accounts = this.accounts.map((a) => ({ ...a, newlyAdded: false }))\n    this.emitUpdate()\n  }\n\n  async forceFetchPendingState(addr: string, chainId: bigint): Promise<AccountOnchainState> {\n    await this.updateAccountState(addr, 'pending', [chainId])\n    return this.accountStates[addr][chainId.toString()]\n  }\n\n  toJSON() {\n    return {\n      ...this,\n      ...super.toJSON(),\n      areAccountStatesLoading: this.areAccountStatesLoading\n    }\n  }\n}\n"]}