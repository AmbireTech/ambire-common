{"version":3,"file":"providers.js","sourceRoot":"","sources":["../../../../src/controllers/providers/providers.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,cAAc,EAAE,MAAM,yBAAyB,CAAA;AACxD,OAAO,YAAY,MAAM,8BAA8B,CAAA;AAGvD;;;GAGG;AACH,MAAM,OAAO,mBAAoB,SAAQ,YAAY;IACnD,SAAS,CAAoB;IAE7B,SAAS,GAAiB,EAAE,CAAA;IAE5B,0EAA0E;IAC1E,kBAAkB,CAAe;IAEjC,YAAY,QAA4B;QACtC,KAAK,EAAE,CAAA;QAEP,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAA;QACzB,mEAAmE;QACnE,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,KAAK,EAAE,CAAA;IACxC,CAAC;IAED,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,SAAS,CAAC,aAAa,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CAAA;IAC7E,CAAC;IAED,KAAK,CAAC,KAAK;QACT,MAAM,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAA;QACvC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAA;QAC3D,IAAI,CAAC,UAAU,EAAE,CAAA;IACnB,CAAC;IAED,WAAW,CAAC,OAAgB;QAC1B,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;QAE3C,mHAAmH;QACnH,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE,cAAc,EAAE,CAAC,GAAG,KAAK,OAAO,CAAC,cAAc,EAAE;YAC1E,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;YAEzC,wIAAwI;YACxI,IAAI,MAAM;gBAAE,MAAM,CAAC,OAAO,EAAE,CAAA;YAE5B,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,cAAc,CACzC,OAAO,CAAC,OAAO,EACf,OAAO,CAAC,OAAO,EACf,OAAO,CAAC,cAAc,CACvB,CAAA;SACF;IACH,CAAC;IAED,uBAAuB,CAAC,SAAoB,EAAE,SAAkB;QAC9D,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;YAAE,OAAM;QACtC,IAAI,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,SAAS,KAAK,SAAS;YAAE,OAAM;QAE7D,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,SAAS,GAAG,SAAS,CAAA;QAC/C,IAAI,CAAC,UAAU,EAAE,CAAA;IACnB,CAAC;IAED,cAAc,CAAC,SAAoB;QACjC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;YAAE,OAAM;QAEtC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,CAAA;QACpC,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAA;QAChC,IAAI,CAAC,UAAU,EAAE,CAAA;IACnB,CAAC;IAED,MAAM;QACJ,OAAO;YACL,GAAG,IAAI;YACP,GAAG,KAAK,CAAC,MAAM,EAAE;YACjB,aAAa,EAAE,IAAI,CAAC,aAAa;SAClC,CAAA;IACH,CAAC;CACF","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { Network, NetworkId } from '../../interfaces/network'\nimport { RPCProviders } from '../../interfaces/provider'\nimport { getRpcProvider } from '../../services/provider'\nimport EventEmitter from '../eventEmitter/eventEmitter'\nimport { NetworksController } from '../networks/networks'\n\n/**\n * The ProvidersController manages RPC providers, enabling the extension to communicate with the blockchain.\n * Each network requires an initialized JsonRpcProvider, and the provider must be reinitialized whenever network.selectedRpcUrl changes.\n */\nexport class ProvidersController extends EventEmitter {\n  #networks: NetworksController\n\n  providers: RPCProviders = {}\n\n  // Holds the initial load promise, so that one can wait until it completes\n  initialLoadPromise: Promise<void>\n\n  constructor(networks: NetworksController) {\n    super()\n\n    this.#networks = networks\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.initialLoadPromise = this.#load()\n  }\n\n  get isInitialized() {\n    return this.#networks.isInitialized && !!Object.keys(this.providers).length\n  }\n\n  async #load() {\n    await this.#networks.initialLoadPromise\n    this.#networks.networks.forEach((n) => this.setProvider(n))\n    this.emitUpdate()\n  }\n\n  setProvider(network: Network) {\n    const provider = this.providers[network.id]\n\n    // Only update the RPC if the new RPC is different from the current one or if there is no RPC for this network yet.\n    if (!provider || provider?._getConnection().url !== network.selectedRpcUrl) {\n      const oldRPC = this.providers[network.id]\n\n      // If an RPC fails once it will try to reconnect every second. If we don't destroy the old RPC it will keep trying to reconnect forever.\n      if (oldRPC) oldRPC.destroy()\n\n      this.providers[network.id] = getRpcProvider(\n        network.rpcUrls,\n        network.chainId,\n        network.selectedRpcUrl\n      )\n    }\n  }\n\n  updateProviderIsWorking(networkId: NetworkId, isWorking: boolean) {\n    if (!this.providers[networkId]) return\n    if (this.providers[networkId].isWorking === isWorking) return\n\n    this.providers[networkId].isWorking = isWorking\n    this.emitUpdate()\n  }\n\n  removeProvider(networkId: NetworkId) {\n    if (!this.providers[networkId]) return\n\n    this.providers[networkId]?.destroy()\n    delete this.providers[networkId]\n    this.emitUpdate()\n  }\n\n  toJSON() {\n    return {\n      ...this,\n      ...super.toJSON(),\n      isInitialized: this.isInitialized\n    }\n  }\n}\n"]}