{"version":3,"file":"keystore.js","sourceRoot":"","sources":["../../../src/interfaces/keystore.ts"],"names":[],"mappings":";;;AAmGa,QAAA,uBAAuB,GAClC,oEAAoE,CAAA;AACzD,QAAA,oBAAoB,GAC/B,oEAAoE,CAAA","sourcesContent":["import { Transaction } from 'ethers'\n\nimport { EIP7702Auth } from '../consts/7702'\nimport { HD_PATH_TEMPLATE_TYPE } from '../consts/derivation'\nimport { GasFeePayment } from '../libs/accountOp/accountOp'\nimport { Call } from '../libs/accountOp/types'\nimport { getHdPathFromTemplate } from '../utils/hdPath'\nimport { Account } from './account'\nimport { Hex } from './hex'\nimport { Network } from './network'\nimport { EIP7702Signature } from './signatures'\nimport { TypedMessage } from './userRequest'\n\n/**\n * The ExternalSignerController interface defines the structure for controllers\n * that interact with hardware wallets. Each hardware wallet type (Ledger,\n * Trezor, Lattice) will have its own implementation of this interface.\n * The interface includes methods for unlocking the device, checking if it's\n * unlocked, and cleaning up after use. It also includes properties specific to\n * each type of hardware wallet, such as the device model and ID, the path to\n * the unlocked device, and any necessary credentials.\n */\nexport interface ExternalSignerController {\n  type: string\n  deviceModel: string\n  deviceId: string\n  isUnlocked: (path?: string, expectedKeyOnThisPath?: string) => boolean\n  unlock: (\n    path: ReturnType<typeof getHdPathFromTemplate>,\n    expectedKeyOnThisPath?: string,\n    shouldOpenLatticeConnectorInTab?: boolean // Lattice specific\n  ) => Promise<'ALREADY_UNLOCKED' | 'JUST_UNLOCKED'>\n  unlockedPath: string\n  unlockedPathKeyAddr: string\n  walletSDK?: any // Either the wallet own SDK or its session, each wallet having specifics\n  cleanUp: () => void // Trezor and Ledger specific\n  isInitiated?: boolean // Trezor specific\n  initialLoadPromise?: Promise<void> // Trezor specific\n  retrieveAddresses?: (paths: string[]) => Promise<string[]> // Ledger specific\n  // TODO: Refine the rest of the props\n  isWebHID?: boolean // Ledger specific\n  transport?: any // Ledger specific\n  appName?: string // Lattice specific\n  creds?: any // Lattice specific\n  network?: any // Lattice specific\n}\nexport type ExternalSignerControllers = Partial<{ [key in Key['type']]: ExternalSignerController }>\n\nexport interface TxnRequest {\n  to: Call['to']\n  value?: Call['value']\n  data: Call['data']\n  chainId: Network['chainId']\n  nonce: number\n  gasLimit: GasFeePayment['simulatedGasLimit']\n  gasPrice?: bigint\n  maxFeePerGas?: bigint\n  maxPriorityFeePerGas?: bigint\n  type?: number\n}\n\nexport interface KeystoreSignerInterface {\n  key: Key\n  init?: (externalSignerController?: ExternalSignerController) => void\n  signRawTransaction: (txnRequest: TxnRequest) => Promise<Transaction['serialized']>\n  signTypedData: (typedMessage: TypedMessage) => Promise<string>\n  signMessage: (hex: string) => Promise<string>\n  sign7702: (hex: string) => EIP7702Signature\n  signTransactionTypeFour: (txnRequest: TxnRequest, eip7702Auth: EIP7702Auth) => Hex\n}\n\nexport type ScryptParams = {\n  salt: string\n  N: number\n  r: number\n  p: number\n  dkLen: number\n}\n\nexport type AESEncrypted = {\n  cipherType: string\n  ciphertext: string\n  iv: string\n  mac: string\n}\n\nexport type MainKeyEncryptedWithSecret = {\n  id: string\n  scryptParams: ScryptParams\n  aesEncrypted: AESEncrypted\n}\n\nexport type MainKey = {\n  key: Uint8Array\n  iv: Uint8Array\n}\n\nexport type Key = (InternalKey | ExternalKey) & { isExternallyStored: boolean }\n\nexport const standardSigningOnlyPriv =\n  '0x0000000000000000000000000000000000000000000000000000000000000001'\nexport const dedicatedToOneSAPriv =\n  '0x0000000000000000000000000000000000000000000000000000000000000002'\n\nexport type InternalKey = {\n  addr: Account['addr']\n  type: 'internal'\n  label: string\n  dedicatedToOneSA: boolean\n  meta: {\n    createdAt: number | null\n    fromSeedId?: string\n    [key: string]: any\n  }\n}\n\nexport type ExternalKey = {\n  addr: Account['addr']\n  type: 'trezor' | 'ledger' | 'lattice'\n  label: string\n  dedicatedToOneSA: boolean\n  meta: {\n    deviceId: string\n    deviceModel: string\n    hdPathTemplate: HD_PATH_TEMPLATE_TYPE\n    index: number\n    createdAt: number | null\n    [key: string]: any\n  }\n}\n\nexport type StoredKey = (InternalKey & { privKey: string }) | (ExternalKey & { privKey: null })\n\nexport type KeystoreSeed = {\n  id: string\n  label: string\n  seed: string\n  seedPassphrase?: string | null\n  hdPathTemplate: HD_PATH_TEMPLATE_TYPE\n}\n\nexport type KeystoreSignerType = {\n  new (key: Key, privateKey?: string): KeystoreSignerInterface\n}\n\n/**\n * The keys that are ready to be added to the user's keystore (by the Main Controller).\n * They are needed as an intermediate step during the accounts import flow\n * (for the accounts that were just imported by the AccountPicker Controller).\n */\nexport type ReadyToAddKeys = {\n  internal: {\n    addr: InternalKey['addr']\n    label: string\n    type: InternalKey['type']\n    privateKey: string\n    dedicatedToOneSA: InternalKey['dedicatedToOneSA']\n    meta: InternalKey['meta']\n  }[]\n  external: {\n    addr: ExternalKey['addr']\n    label: string\n    type: ExternalKey['type']\n    dedicatedToOneSA: Key['dedicatedToOneSA']\n    meta: ExternalKey['meta']\n  }[]\n}\n\nexport type KeyPreferences = {\n  label: string\n}\n"]}