{"version":3,"file":"keystore.js","sourceRoot":"","sources":["../../../src/interfaces/keystore.ts"],"names":[],"mappings":"AA8FA,MAAM,CAAC,MAAM,uBAAuB,GAClC,oEAAoE,CAAA;AACtE,MAAM,CAAC,MAAM,oBAAoB,GAC/B,oEAAoE,CAAA","sourcesContent":["import { Transaction } from 'ethers'\n\nimport { HD_PATH_TEMPLATE_TYPE } from '../consts/derivation'\nimport { GasFeePayment } from '../libs/accountOp/accountOp'\nimport { Call } from '../libs/accountOp/types'\nimport { getHdPathFromTemplate } from '../utils/hdPath'\nimport { Account } from './account'\nimport { Network } from './network'\nimport { TypedMessage } from './userRequest'\n\n/**\n * The ExternalSignerController interface defines the structure for controllers\n * that interact with hardware wallets. Each hardware wallet type (Ledger,\n * Trezor, Lattice) will have its own implementation of this interface.\n * The interface includes methods for unlocking the device, checking if it's\n * unlocked, and cleaning up after use. It also includes properties specific to\n * each type of hardware wallet, such as the device model and ID, the path to\n * the unlocked device, and any necessary credentials.\n */\nexport interface ExternalSignerController {\n  type: string\n  deviceModel: string\n  deviceId: string\n  isUnlocked: (path?: string, expectedKeyOnThisPath?: string) => boolean\n  unlock: (\n    path: ReturnType<typeof getHdPathFromTemplate>,\n    expectedKeyOnThisPath?: string,\n    shouldOpenLatticeConnectorInTab?: boolean // Lattice specific\n  ) => Promise<'ALREADY_UNLOCKED' | 'JUST_UNLOCKED'>\n  unlockedPath: string\n  unlockedPathKeyAddr: string\n  walletSDK?: any // Either the wallet own SDK or its session, each wallet having specifics\n  cleanUp: () => void // Trezor and Ledger specific\n  isInitiated?: boolean // Trezor specific\n  initialLoadPromise?: Promise<void> // Trezor specific\n  retrieveAddresses: (paths: string[]) => Promise<string[]> // Ledger specific\n  // TODO: Refine the rest of the props\n  isWebHID?: boolean // Ledger specific\n  transport?: any // Ledger specific\n  appName?: string // Lattice specific\n  creds?: any // Lattice specific\n  network?: any // Lattice specific\n}\nexport type ExternalSignerControllers = Partial<{ [key in Key['type']]: ExternalSignerController }>\n\nexport interface TxnRequest {\n  to: Call['to']\n  value?: Call['value']\n  data: Call['data']\n  chainId: Network['chainId']\n  nonce: number\n  gasLimit: GasFeePayment['simulatedGasLimit']\n  gasPrice?: bigint\n  maxFeePerGas?: bigint\n  maxPriorityFeePerGas?: bigint\n  type?: number\n}\n\nexport interface KeystoreSigner {\n  key: Key\n  init?: (externalSignerController?: ExternalSignerController) => void\n  signRawTransaction: (txnRequest: TxnRequest) => Promise<Transaction['serialized']>\n  signTypedData: (typedMessage: TypedMessage) => Promise<string>\n  signMessage: (hex: string) => Promise<string>\n}\n\nexport type ScryptParams = {\n  salt: string\n  N: number\n  r: number\n  p: number\n  dkLen: number\n}\n\nexport type AESEncrypted = {\n  cipherType: string\n  ciphertext: string\n  iv: string\n  mac: string\n}\n\nexport type MainKeyEncryptedWithSecret = {\n  id: string\n  scryptParams: ScryptParams\n  aesEncrypted: AESEncrypted\n}\n\nexport type MainKey = {\n  key: Uint8Array\n  iv: Uint8Array\n}\n\nexport type Key = (InternalKey | ExternalKey) & { isExternallyStored: boolean }\n\nexport const standardSigningOnlyPriv =\n  '0x0000000000000000000000000000000000000000000000000000000000000001'\nexport const dedicatedToOneSAPriv =\n  '0x0000000000000000000000000000000000000000000000000000000000000002'\n\nexport type InternalKey = {\n  addr: Account['addr']\n  type: 'internal'\n  label: string\n  dedicatedToOneSA: boolean\n  meta: {\n    createdAt: number | null\n  }\n}\n\nexport type ExternalKey = {\n  addr: Account['addr']\n  type: 'trezor' | 'ledger' | 'lattice' | string\n  label: string\n  dedicatedToOneSA: boolean\n  meta: {\n    deviceId: string\n    deviceModel: string\n    hdPathTemplate: HD_PATH_TEMPLATE_TYPE\n    index: number\n    createdAt: number | null\n  }\n}\n\nexport type StoredKey = (InternalKey & { privKey: string }) | (ExternalKey & { privKey: null })\n\nexport type KeystoreSeed = { seed: string; hdPathTemplate: HD_PATH_TEMPLATE_TYPE }\n\nexport type KeystoreSignerType = {\n  new (key: Key, privateKey?: string): KeystoreSigner\n}\n\n/**\n * The keys that are ready to be added to the user's keystore (by the Main Controller).\n * They are needed as an intermediate step during the accounts import flow\n * (for the accounts that were just imported by the AccountAdder Controller).\n */\nexport type ReadyToAddKeys = {\n  internal: {\n    addr: Key['addr']\n    label: string\n    type: 'internal'\n    privateKey: string\n    dedicatedToOneSA: Key['dedicatedToOneSA']\n    meta: InternalKey['meta']\n  }[]\n  external: {\n    addr: Key['addr']\n    label: string\n    type: Key['type']\n    dedicatedToOneSA: Key['dedicatedToOneSA']\n    meta: ExternalKey['meta']\n  }[]\n}\n\nexport type KeyPreferences = {\n  label: string\n}\n"]}