{"version":3,"file":"timeout.js","sourceRoot":"","sources":["../../../src/utils/timeout.ts"],"names":[],"mappings":";;AAGA,wDAwBC;AA3BD,oFAAoF;AACpF,wFAAwF;AACxF,oEAAoE;AACpE,SAAgB,sBAAsB,CACpC,EAAuB,EACvB,OAAe;IAEf,IAAI,SAAqC,CAAA;IAEzC,MAAM,IAAI,GAAG,GAAG,EAAE;QAChB,YAAY,CAAC,SAAS,CAAC,CAAA;QACvB,SAAS,GAAG,SAAS,CAAA;IACvB,CAAC,CAAA;IAED,MAAM,KAAK,GAAG,GAAG,EAAE;QACjB,IAAI,SAAS;YAAE,IAAI,EAAE,CAAA;QAErB,SAAS,GAAG,UAAU,CAAC,KAAK,IAAI,EAAE;YAChC,MAAM,EAAE,EAAE,CAAA;YACV,KAAK,EAAE,CAAA;QACT,CAAC,EAAE,OAAO,CAAC,CAAA;IACb,CAAC,CAAA;IAED,OAAO;QACL,KAAK;QACL,IAAI;KACL,CAAA;AACH,CAAC","sourcesContent":["// Execute `fn` at a specific interval, ensuring that the current invocation of `fn`\n// completes before the next one starts. This serves as an alternative to `setInterval`,\n// but providing protection against overlapping invocations of `fn`.\nexport function createRecurringTimeout(\n  fn: () => Promise<void>,\n  timeout: number\n): { start: () => void; stop: () => void } {\n  let timeoutId: NodeJS.Timeout | undefined\n\n  const stop = () => {\n    clearTimeout(timeoutId)\n    timeoutId = undefined\n  }\n\n  const start = () => {\n    if (timeoutId) stop()\n\n    timeoutId = setTimeout(async () => {\n      await fn()\n      start()\n    }, timeout)\n  }\n\n  return {\n    start,\n    stop\n  }\n}\n"]}