{"version":3,"file":"assetInfo.js","sourceRoot":"","sources":["../../../../src/services/assetInfo/assetInfo.ts"],"names":[],"mappings":"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","sourcesContent":["import { JsonRpcProvider } from 'ethers'\n\nimport { Network, NetworkId } from '../../interfaces/network'\nimport { GetOptions, Portfolio } from '../../libs/portfolio'\n\nconst RANDOM_ADDRESS = '0x0000000000000000000000000000000000000001'\nconst scheduledActions: {\n  [network in NetworkId]?: {\n    promise: Promise<any>\n    data: { callback: Function; address: string }[]\n  }\n} = {}\n\nexport async function executeBatchedFetch(network: Network): Promise<void> {\n  const provider = new JsonRpcProvider(network.selectedRpcUrl || network.rpcUrls[0])\n  const allAddresses =\n    Array.from(new Set(scheduledActions[network.id]?.data.map((i) => i.address))) || []\n  const portfolio = new Portfolio(fetch as any, provider, network)\n  const options: Partial<GetOptions> = {\n    disableAutoDiscovery: true,\n    additionalErc20Hints: allAddresses,\n    additionalErc721Hints: Object.fromEntries(\n      allAddresses.map((i) => [\n        i,\n        {\n          tokens: ['1'],\n          isKnown: false\n        }\n      ])\n    )\n  }\n  const portfolioResponse = await portfolio.get(RANDOM_ADDRESS, options)\n\n  scheduledActions[network.id]?.data.forEach((i) => {\n    const tokenInfo =\n      (i.address,\n      portfolioResponse.tokens.find(\n        (t) => t.address.toLocaleLowerCase() === i.address.toLowerCase()\n      ))\n    const nftInfo =\n      (i.address,\n      portfolioResponse.collections.find(\n        (t) => t.address.toLocaleLowerCase() === i.address.toLowerCase()\n      ))\n\n    i.callback({ tokenInfo, nftInfo })\n  })\n}\n\n/**\n * Resolves symbol and decimals for tokens or name for nfts.\n */\nexport async function resolveAssetInfo(\n  address: string,\n  network: Network,\n  callback: (arg: {\n    tokenInfo?: { decimals: number; symbol: string }\n    nftInfo?: { name: string }\n  }) => void\n): Promise<void> {\n  if (!scheduledActions[network.id]?.data?.length) {\n    scheduledActions[network.id] = {\n      promise: new Promise((resolve, reject) => {\n        setTimeout(async () => {\n          await executeBatchedFetch(network).catch(reject)\n          scheduledActions[network.id] = undefined\n          resolve(0)\n        }, 500)\n      }),\n      data: [{ address, callback }]\n    }\n  } else {\n    scheduledActions[network.id]?.data.push({ address, callback })\n  }\n  // we are returning a promise so we can await the full execution\n  return scheduledActions[network.id]?.promise\n}\n"]}