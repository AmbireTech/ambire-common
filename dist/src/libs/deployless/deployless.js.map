{"version":3,"file":"deployless.js","sourceRoot":"","sources":["../../../../src/libs/deployless/deployless.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'assert'\nimport { AbiCoder, concat, getBytes, Interface, JsonRpcProvider, Provider } from 'ethers'\n\nimport DeploylessCompiled from '../../../contracts/compiled/Deployless.json'\n\n// this is a magic contract that is constructed like `constructor(bytes memory contractBytecode, bytes memory data)` and returns the result from the call\n// compiled from relayer:a7ea373559d8c419577ac05527bd37fbee8856ae/src/velcro-v3/contracts/Deployless.sol with solc 0.8.17\nconst deploylessProxyBin = DeploylessCompiled.bin\n// This is another magic contract that can return the contract code at an address; this is not the deploy bytecode but rather the contract code itself\n// see https://gist.github.com/Ivshti/fbcc37c0a8b88d6e51bb30db57f3d50e\nconst codeOfContractCode =\n  '0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631e05758f14610030575b600080fd5b61004a60048036038101906100459190610248565b61004c565b005b60008151602083016000f0905060008173ffffffffffffffffffffffffffffffffffffffff163b036100aa576040517fb4f5411100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff16803b806020016040519081016040528181526000908060200190933c90506000815190508060208301f35b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6101558261010c565b810181811067ffffffffffffffff821117156101745761017361011d565b5b80604052505050565b60006101876100ee565b9050610193828261014c565b919050565b600067ffffffffffffffff8211156101b3576101b261011d565b5b6101bc8261010c565b9050602081019050919050565b82818337600083830152505050565b60006101eb6101e684610198565b61017d565b90508281526020810184848401111561020757610206610107565b5b6102128482856101c9565b509392505050565b600082601f83011261022f5761022e610102565b5b813561023f8482602086016101d8565b91505092915050565b60006020828403121561025e5761025d6100f8565b5b600082013567ffffffffffffffff81111561027c5761027b6100fd565b5b6102888482850161021a565b9150509291505056fea2646970667358221220de4923c71abcedf68454c251a9becff7e8a4f8db4adee6fdb16d583f509c63bb64736f6c63430008120033'\nconst codeOfContractAbi = ['function codeOf(bytes deployCode) external view']\n\n// The custom error that both these contracts will raise in case the deploy process of the contract goes wrong\n// error DeployFailed();\nconst deployErrorSig = '0xb4f54111'\n// Signature of Error(string)\nconst errorSig = '0x08c379a0'\n// LBRouter__InvalidTokenPath\nconst invalidPath = '0x4feac00c'\n// Signature of Panic(uint256)\nconst panicSig = '0x4e487b71'\n// uniswap swap expired\nconst expiredSwap = '0x5bf6f916'\n// uniswap signature expired\nconst expiredSig = '0xcd21db4f'\n\n// any made up addr would work\nconst arbitraryAddr = '0x0000000000000000000000000000000000696969'\nconst abiCoder = new AbiCoder()\n\nexport enum DeploylessMode {\n  Detect,\n  ProxyContract,\n  StateOverride\n}\nexport type CallOptions = {\n  mode: DeploylessMode\n  // Note: some RPCs don't seem to like numbers, we can use hex strings for them\n  blockTag: string | number\n  from?: string\n  to?: string\n  gasPrice?: string\n  gasLimit?: string\n  stateToOverride: object | null\n}\nconst defaultOptions: CallOptions = {\n  mode: DeploylessMode.Detect,\n  blockTag: 'latest',\n  from: undefined,\n  to: arbitraryAddr,\n  stateToOverride: null\n}\n\nexport class Deployless {\n  private iface: Interface\n\n  // the contract deploy (constructor) code: this is the code that tjhe solidity compiler outputs\n  private contractBytecode: string\n\n  private provider: JsonRpcProvider | Provider\n\n  private isProviderInvictus: boolean = false\n\n  // We need to detect whether the provider supports state override\n  private detectionPromise?: Promise<void>\n\n  private stateOverrideSupported?: boolean\n\n  // the code of the contract after it's actually deployed (or in our case, simulate-deployed)\n  // see this: https://medium.com/coinmonks/the-difference-between-bytecode-and-deployed-bytecode-64594db723df\n  private contractRuntimeCode?: string\n\n  public get isLimitedAt24kbData() {\n    return !this.stateOverrideSupported\n  }\n\n  constructor(\n    provider: JsonRpcProvider | Provider,\n    abi: any[],\n    code: string,\n    codeAtRuntime?: string\n  ) {\n    assert.ok(code.startsWith('0x'), 'contract code must start with 0x')\n    assert.ok(\n      !abi.includes((x: any) => x.type === 'constructor'),\n      'contract cannot have a constructor, as it is not supported in state override mode'\n    )\n    this.contractBytecode = code\n    this.provider = provider\n    // eslint-disable-next-line no-underscore-dangle\n    this.isProviderInvictus = (provider as any)._getConnection().url.includes('invictus')\n    this.iface = new Interface(abi)\n    if (codeAtRuntime !== undefined) {\n      assert.ok(codeAtRuntime.startsWith('0x'), 'contract code (runtime) must start with 0x')\n      this.stateOverrideSupported = true\n      this.contractRuntimeCode = codeAtRuntime\n    }\n  }\n\n  // this will detect whether the provider supports state override and also retrieve the actual code of the contract we are using\n  private async detectStateOverride(): Promise<void> {\n    const isJsonRpcProvider =\n      this.provider &&\n      typeof (this.provider as JsonRpcProvider).send === 'function' &&\n      // eslint-disable-next-line no-underscore-dangle\n      typeof (this.provider as JsonRpcProvider)._send === 'function'\n\n    if (!isJsonRpcProvider) {\n      throw new Error(\n        'state override mode (or auto-detect) not available unless you use JsonRpcProvider'\n      )\n    }\n    const codeOfIface = new Interface(codeOfContractAbi)\n    const code = await mapError(\n      (this.provider as JsonRpcProvider).send('eth_call', [\n        {\n          to: arbitraryAddr,\n          data: codeOfIface.encodeFunctionData('codeOf', [this.contractBytecode])\n        },\n        'latest',\n        { [arbitraryAddr]: { code: codeOfContractCode } }\n      ])\n    )\n    // any response bigger than 0x is sufficient to know that state override worked\n    // the response would be just \"0x\" if state override doesn't work\n    this.stateOverrideSupported = code.startsWith('0x') && code.length > 2\n    this.contractRuntimeCode = mapResponse(code)\n  }\n\n  async call(methodName: string, args: any[], opts: Partial<CallOptions> = {}): Promise<any> {\n    opts = { ...defaultOptions, ...opts }\n    const forceProxy = opts.mode === DeploylessMode.ProxyContract\n\n    // First, start by detecting which modes are available, unless we're forcing the proxy mode\n    // if we use state override, we do need detection to run still so it can populate contractRuntimeCode\n    if (\n      this.stateOverrideSupported &&\n      !this.detectionPromise &&\n      !forceProxy &&\n      this.contractRuntimeCode === undefined\n    ) {\n      this.detectionPromise = this.detectStateOverride()\n    }\n    await this.detectionPromise\n\n    if (opts.stateToOverride !== null && opts.mode !== DeploylessMode.StateOverride) {\n      throw new Error('state override passed but not requested')\n    }\n    if (opts.mode === DeploylessMode.StateOverride && !this.stateOverrideSupported) {\n      throw new Error(`${methodName}: state override requested but not supported`)\n    }\n\n    const callData = this.iface.encodeFunctionData(methodName, args)\n    const toAddr = opts.to ?? arbitraryAddr\n    const callPromise =\n      !!this.stateOverrideSupported && !forceProxy\n        ? (this.provider as JsonRpcProvider).send('eth_call', [\n            {\n              to: toAddr,\n              data: callData,\n              from: opts.from,\n              gasPrice: opts?.gasPrice,\n              gas: opts?.gasLimit\n            },\n            opts.blockTag,\n            {\n              [toAddr]: { code: this.contractRuntimeCode },\n              ...(opts.stateToOverride || {})\n            }\n          ])\n        : this.provider.call({\n            blockTag: opts.blockTag,\n            from: opts.from,\n            gasPrice: opts?.gasPrice,\n            gasLimit: opts?.gasLimit,\n            data: checkDataSize(\n              concat([\n                deploylessProxyBin,\n                abiCoder.encode(['bytes', 'bytes'], [this.contractBytecode, callData])\n              ])\n            )\n          })\n\n    // The ethers' providers retry failed calls every 1 second, making numerous attempts before finally resolving the promise.\n    // To prevent prolonged retries, we use Promise.race to set a 10-second timeout. This way, the callPromise will either resolve\n    // or the timeout promise will reject after 10 seconds, whichever occurs first.\n    const callPromisedWithResolveTimeout = Promise.race([\n      callPromise,\n      new Promise((_resolve, reject) => {\n        // Custom providers may take longer to respond, so we set a longer timeout for them.\n        setTimeout(() => reject(new Error('rpc-timeout')), this.isProviderInvictus ? 5000 : 15000)\n      })\n    ])\n\n    const returnDataRaw = mapResponse(await mapError(callPromisedWithResolveTimeout))\n    return this.iface.decodeFunctionResult(methodName, returnDataRaw)\n  }\n}\n\nexport function fromDescriptor(\n  provider: JsonRpcProvider | Provider,\n  desc: { abi: any; bin: string; binRuntime: string },\n  supportStateOverride: boolean\n): Deployless {\n  return new Deployless(\n    provider,\n    desc.abi,\n    desc.bin,\n    supportStateOverride ? desc.binRuntime : undefined\n  )\n}\n\nasync function mapError(callPromise: Promise<string>): Promise<string> {\n  try {\n    return await callPromise\n  } catch (e: any) {\n    // ethers v5 provider: e.error.data is usually our eth_call output in case of execution reverted\n    if (e.error && e.error.data) return e.error.data\n    // ethers v5 provider: unwrap the wrapping that ethers adds to this type of error in case of provider.call\n    if (e.code === 'CALL_EXCEPTION' && e.error) throw e.error\n    // ethers v6 provider: wrapping the error in case of execution reverted\n    if (e.code === 'CALL_EXCEPTION' && e.data) return e.data\n    throw e\n  }\n}\n\nfunction mapResponse(data: string): string {\n  if (data === deployErrorSig) throw new Error('contract deploy failed')\n  const err = parseErr(data)\n  if (err) throw err\n  return data\n}\n\nexport function parseErr(data: string): string | null {\n  const dataNoPrefix = data.slice(10)\n  if (data.startsWith(panicSig)) {\n    // https://docs.soliditylang.org/en/v0.8.11/control-structures.html#panic-via-assert-and-error-via-require\n    const num = parseInt(`0x${dataNoPrefix}`)\n    if (num === 0x00) return 'generic compiler error'\n    if (num === 0x01) return 'solidity assert error'\n    if (num === 0x11) return 'arithmetic error'\n    if (num === 0x12) return 'division by zero'\n    return `panic error: 0x${num.toString(16)}`\n  }\n  if (data.startsWith(errorSig)) {\n    try {\n      return abiCoder.decode(['string'], `0x${dataNoPrefix}`)[0]\n    } catch (e: any) {\n      if (e.code === 'BUFFER_OVERRUN' || e.code === 'NUMERIC_FAULT') return dataNoPrefix\n      return e\n    }\n  }\n  if (data.startsWith(invalidPath)) {\n    return 'Transaction cannot be sent due to invalid swap path provided by the app that initiated the request. Please return to the app interface and try again.'\n  }\n  // uniswap expired error\n  if (data === expiredSwap) {\n    return 'Transaction cannot be sent because the swap has expired. Please return to the app interface and try again.'\n  }\n  // uniswap signature expired error\n  if (data.startsWith(expiredSig)) {\n    return 'Transaction cannot be sent because the signature involved in this swap has expired. Please return to the app interface and try again.'\n  }\n  return null\n}\n\nfunction checkDataSize(data: string): string {\n  if (getBytes(data).length >= 24576)\n    throw new Error(\n      'Transaction cannot be sent because the 24kb call data size limit has been reached. Please use StateOverride mode instead.'\n    )\n  return data\n}\n"]}