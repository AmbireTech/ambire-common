{"version":3,"file":"simulateDeployCall.js","sourceRoot":"","sources":["../../../../src/libs/deployless/simulateDeployCall.ts"],"names":[],"mappings":";;AAYA,oCAgDC;;AA5DD,mCAAqD;AAErD,gHAA0E;AAC1E,gDAAwF;AACxF,gDAA8D;AAC9D,sDAAoD;AACpD,kEAAiE;AACjE,6CAA6D;AAE7D,oDAAoD;AACpD,0EAA0E;AAC1E,uBAAuB;AAChB,KAAK,UAAU,YAAY,CAChC,QAAyB;IAEzB,MAAM,YAAY,GAAG,MAAM,IAAA,yBAAe,EACxC;QACE;YACE,IAAI,EAAE,mCAA0B;YAChC,IAAI,EAAE,oEAAoE;SAC3E;KACF,EACD,EAAE,CACH,CAAA;IACD,MAAM,iBAAiB,GAAG;QACxB,QAAQ,EAAE,QAAQ;QAClB,IAAI,EAAE,mCAA0B;QAChC,uDAAuD;QACvD,qCAAqC;QACrC,EAAE,EAAE,+BAAsB;QAC1B,IAAI,EAAE,2BAAc,CAAC,aAAa;KACnC,CAAA;IACD,MAAM,UAAU,GAAG,IAAA,2BAAc,EAAC,QAAQ,EAAE,4BAAa,EAAE,IAAI,CAAC,CAAA;IAChE,IAAI,qBAAqB,GAAG,IAAI,CAAA;IAChC,MAAM,MAAM,GAAG,MAAM,UAAU;SAC5B,IAAI,CACH,kBAAkB,EAClB;QACE,YAAY,CAAC,QAAS,CAAC,QAAQ;QAC/B,YAAY,CAAC,QAAS,CAAC,IAAI;QAC3B,CAAC,IAAA,uBAAW,EAAC,IAAA,gCAAgB,EAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QAClD,IAAA,kBAAQ,EAAC,YAAY,CAAC;KACvB,EACD,iBAAiB,CAClB;SACA,KAAK,CAAC,CAAC,CAAM,EAAE,EAAE;QAChB,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE,CAAC;YACtC,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAA;QAChC,CAAC;QAED,+DAA+D;QAC/D,6DAA6D;QAC7D,qBAAqB,GAAG,KAAK,CAAA;QAC7B,OAAO,CAAC,oBAAW,CAAC,CAAA;IACtB,CAAC,CAAC,CAAA;IAEJ,OAAO;QACL,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,YAAY,CAAC,IAAI;QAC/C,qBAAqB;KACtB,CAAA;AACH,CAAC","sourcesContent":["import { JsonRpcProvider, ZeroAddress } from 'ethers'\n\nimport AmbireFactory from '../../../contracts/compiled/AmbireFactory.json'\nimport { AMBIRE_ACCOUNT_FACTORY, DEPLOYLESS_SIMULATION_FROM } from '../../consts/deploy'\nimport { getSmartAccount, getSpoof } from '../account/account'\nimport { callToTuple } from '../accountOp/accountOp'\nimport { getActivatorCall } from '../userOperation/userOperation'\nimport { DeploylessMode, fromDescriptor } from './deployless'\n\n// simulate a deployless call to the given provider.\n// if the call is successful, it means Ambire smart accounts are supported\n// on the given network\nexport async function getSASupport(\n  provider: JsonRpcProvider\n): Promise<{ addressMatches: boolean; supportsStateOverride: boolean }> {\n  const smartAccount = await getSmartAccount(\n    [\n      {\n        addr: DEPLOYLESS_SIMULATION_FROM,\n        hash: '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n      }\n    ],\n    []\n  )\n  const deploylessOptions = {\n    blockTag: 'latest',\n    from: DEPLOYLESS_SIMULATION_FROM,\n    // very important to send to the AMBIRE_ACCOUNT_FACTORY\n    // or else the SA address won't match\n    to: AMBIRE_ACCOUNT_FACTORY,\n    mode: DeploylessMode.StateOverride\n  }\n  const deployless = fromDescriptor(provider, AmbireFactory, true)\n  let supportsStateOverride = true\n  const result = await deployless\n    .call(\n      'deployAndExecute',\n      [\n        smartAccount.creation!.bytecode,\n        smartAccount.creation!.salt,\n        [callToTuple(getActivatorCall(smartAccount.addr))],\n        getSpoof(smartAccount)\n      ],\n      deploylessOptions\n    )\n    .catch((e: any) => {\n      if (e.message.includes('no response')) {\n        throw new Error('no response')\n      }\n\n      // if there's an error, return the zero address indicating that\n      // our smart accounts will most likely not work on this chain\n      supportsStateOverride = false\n      return [ZeroAddress]\n    })\n\n  return {\n    addressMatches: result[0] === smartAccount.addr,\n    supportsStateOverride\n  }\n}\n"]}