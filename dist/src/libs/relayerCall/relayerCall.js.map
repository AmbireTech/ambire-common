{"version":3,"file":"relayerCall.js","sourceRoot":"","sources":["../../../../src/libs/relayerCall/relayerCall.ts"],"names":[],"mappings":";;;AAEA,mDAAuD;AAEvD,MAAa,YAAa,SAAQ,KAAK;IAC9B,KAAK,CAAK;IAEV,MAAM,CAAK;IAElB,YAAY,OAAe,EAAE,KAAU,EAAE,MAAW;QAClD,KAAK,CAAC,OAAO,CAAC,CAAA;QACd,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;QAClB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;IACtB,CAAC;CACF;AAVD,oCAUC;AACY,QAAA,oBAAoB,GAC/B,kGAAkG,CAAA;AAE7F,KAAK,UAAU,mBAAmB,CACvC,GAAW,EACX,KAAY,EACZ,SAAiB,KAAK,EACtB,OAAY,IAAI,EAChB,UAAe,IAAI;IAEnB,IAAI,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;QAChF,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,YAAY,EAAE,CAAA;IAClD,IAAI,CAAC,GAAG;QAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAA;IAC9D,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;QACpD,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,wBAAwB,EAAE,CAAA;IAE9D,MAAM,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE;QAC3B,MAAM;QACN,OAAO,EAAE;YACP,cAAc,EAAE,kBAAkB;YAClC,GAAG,OAAO;SACX;QACD,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,IAAA,oBAAS,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS;KACzC,CAAC,CAAA;IAEF,MAAM,IAAI,GAAG,MAAM,GAAG,CAAC,IAAI,EAAE,CAAA;IAC7B,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,MAAM,IAAI,GAAG,CAAA;IACxD,IAAI;QACF,MAAM,IAAI,GAAG,IAAA,gBAAK,EAAC,IAAI,CAAC,CAAA;QACxB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;YACnC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,CAAA;SAC5D;QACD,OAAO,EAAE,GAAG,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,CAAA;KAC5E;IAAC,OAAO,CAAC,EAAE;QACV,OAAO;YACL,OAAO,EAAE,KAAK;YACd,IAAI,EAAE,IAAI;YACV,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,OAAO,EAAE,4BAAoB;SAC9B,CAAA;KACF;AACH,CAAC;AAtCD,kDAsCC;AAEM,KAAK,UAAU,WAAW,CAK/B,IAAY,EACZ,SAAiB,KAAK,EACtB,OAAY,IAAI,EAChB,UAAe,IAAI;IAEnB,MAAM,GAAG,GAAG,MAAM,mBAAmB,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;IACzF,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE;QAChB,MAAM,UAAU,GACd,GAAG,CAAC,UAAU,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAA;QACnF,MAAM,IAAI,YAAY,CAAC,UAAU,EAAE,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,CAAA;KAC5F;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAjBD,kCAiBC","sourcesContent":["/* eslint-disable no-prototype-builtins */\nimport { Fetch } from '../../interfaces/fetch'\nimport { parse, stringify } from '../richJson/richJson'\n\nexport class RelayerError extends Error {\n  public input: any\n\n  public output: any\n\n  constructor(message: string, input: any, output: any) {\n    super(message)\n    this.input = input\n    this.output = output\n  }\n}\nexport const RELAYER_DOWN_MESSAGE =\n  'Currently, the Ambire relayer seems to be temporarily down. Please try again a few moments later'\n\nexport async function relayerCallUncaught(\n  url: string,\n  fetch: Fetch,\n  method: string = 'GET',\n  body: any = null,\n  headers: any = null\n) {\n  if (!['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'].includes(method))\n    return { success: false, message: 'bad method' }\n  if (!url) return { success: false, message: 'no url or path' }\n  if (body && ['GET', 'DELETE', 'HEAD'].includes(method))\n    return { success: false, message: 'should not have a body' }\n\n  const res = await fetch(url, {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers\n    },\n    body: body ? stringify(body) : undefined\n  })\n\n  const text = await res.text()\n  const isStatusOk = res.status < 300 && res.status >= 200\n  try {\n    const json = parse(text)\n    if (!json.hasOwnProperty('success')) {\n      return { success: isStatusOk, ...json, status: res.status }\n    }\n    return { ...json, success: json.success && isStatusOk, status: res.status }\n  } catch (e) {\n    return {\n      success: false,\n      data: text,\n      status: res.status,\n      message: RELAYER_DOWN_MESSAGE\n    }\n  }\n}\n\nexport async function relayerCall(\n  this: {\n    url: string\n    fetch: Fetch\n  },\n  path: string,\n  method: string = 'GET',\n  body: any = null,\n  headers: any = null\n): Promise<any> {\n  const res = await relayerCallUncaught(this.url + path, this.fetch, method, body, headers)\n  if (!res.success) {\n    const firstError =\n      res.errorState && res.errorState.length ? res.errorState[0].message : res.message\n    throw new RelayerError(firstError, { url: this.url, path, method, body, headers }, { res })\n  }\n  return res\n}\n"]}