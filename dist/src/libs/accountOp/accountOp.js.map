{"version":3,"file":"accountOp.js","sourceRoot":"","sources":["../../../../src/libs/accountOp/accountOp.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbiCoder, getBytes, Interface, keccak256, toBeHex } from 'ethers'\n\nimport { SINGLETON } from '../../consts/deploy'\nimport { AccountId } from '../../interfaces/account'\n// eslint-disable-next-line import/no-cycle\nimport { Key } from '../../interfaces/keystore'\nimport { NetworkId } from '../../interfaces/network'\nimport { PaymasterService } from '../erc7677/types'\nimport { stringify } from '../richJson/richJson'\nimport { UserOperation } from '../userOperation/types'\nimport { Call } from './types'\n\n// This is an abstract representation of the gas fee payment\n// 1) it cannot contain details about maxFeePerGas/baseFee because some networks might not be aware of EIP-1559; it only cares about total amount\n// 2) it cannot contain info about the mechanism of payment (from EOA but on smart account, pure EOA paying it's fee directly, 4337 paymaster, 4337 direct, relayer, etc.)\n// This info can be inferred when needed from the account type and whether we're running in 4337 mode or not\n// 3) isGasTank and isERC4337 can both be true\n// 4) whether those values are sane will be checked in an additional function (currently `canBroadcast`); for example, this function is meant to ensure that in case of an EOA, the fee is always paid in native\nexport interface GasFeePayment {\n  isERC4337: boolean\n  isGasTank: boolean\n  paidBy: string\n  inToken: string\n  // optional, because older versions of the extension did not have this stored locally\n  feeTokenNetworkId?: NetworkId\n  amount: bigint\n  simulatedGasLimit: bigint\n  gasPrice: bigint\n  maxPriorityFeePerGas?: bigint\n  isSponsored?: boolean\n}\n\nexport enum AccountOpStatus {\n  Pending = 'pending',\n  BroadcastedButNotConfirmed = 'broadcasted-but-not-confirmed',\n  Success = 'success',\n  Failure = 'failure',\n  Rejected = 'rejected',\n  UnknownButPastNonce = 'unknown-but-past-nonce',\n  BroadcastButStuck = 'broadcast-but-stuck'\n}\n\n// Equivalent to ERC-4337 UserOp, but more universal than it since a AccountOp can be transformed to\n// a UserOp, or to a direct EOA transaction, or relayed through the Ambire relayer\n// it is more precisely defined than a UserOp though - UserOp just has calldata and this has individual `calls`\nexport interface AccountOp {\n  accountAddr: string\n  networkId: NetworkId\n  // this may not be defined, in case the user has not picked a key yet\n  signingKeyAddr: Key['addr'] | null\n  signingKeyType: Key['type'] | null\n  // this may not be set in case we haven't set it yet\n  // this is a number and not a bigint because of ethers (it uses number for nonces)\n  nonce: bigint | null\n  // @TODO: nonce namespace? it is dependent on gasFeePayment\n  calls: Call[]\n  // the feeCall is an extra call we add manually when there's a\n  // relayer/paymaster transaction so that the relayer/paymaster\n  // can authorize the payment\n  feeCall?: Call\n  // the activator call is for cases where we want to activate the EntryPoint\n  // it existed previously in the UserOperation type but now it is no longer\n  // limited to it as we can broadcast none ERC-4337 txn with an activatorCall\n  activatorCall?: Call\n  gasLimit: number | null\n  signature: string | null\n  gasFeePayment: GasFeePayment | null\n  // This is used when we have an account recovery to finalize before executing the AccountOp,\n  // And we set this to the recovery finalization AccountOp; could be used in other scenarios too in the future,\n  // for example account migration (from v1 QuickAcc to v2)\n  // theoretically you can recurse these (an AccountOp set as *ToExecuteBefore can have another accountOpToExecuteBefore)\n  // however, in practice we only use this for recovery atm and we never have a case with more than one\n  // Supporting this can done relatively easily via executeMany() for v2 accounts, and with multiple UserOps via 4337 (again v2 accs)\n  accountOpToExecuteBefore: AccountOp | null\n  txnId?: string\n  status?: AccountOpStatus\n  // in the case of ERC-4337, we need an UserOperation structure for the AccountOp\n  asUserOperation?: UserOperation\n  // all kinds of custom accountOp properties that are needed in specific cases\n  meta?: {\n    // pass the entry point authorization signature for the deploy 4337 txn\n    entryPointAuthorization?: string\n    paymasterService?: PaymasterService\n  }\n}\n\n/**\n * If we want to deploy a contract, the to field of Call will actually\n * be empty (undefined). In order to simulate it in a transaction or\n * perform it using a smart account, we need to transform the call to\n * a call to the singleton\n *\n * @param call\n * @returns Call\n */\nexport function toSingletonCall(call: Call): Call {\n  if (call.to) return call\n\n  const singletonABI = [\n    {\n      inputs: [\n        { internalType: 'bytes', name: '_initCode', type: 'bytes' },\n        { internalType: 'bytes32', name: '_salt', type: 'bytes32' }\n      ],\n      name: 'deploy',\n      outputs: [{ internalType: 'address payable', name: 'createdContract', type: 'address' }],\n      stateMutability: 'nonpayable',\n      type: 'function'\n    }\n  ]\n  const singletonInterface = new Interface(singletonABI)\n  return {\n    to: SINGLETON,\n    value: call.value,\n    data: singletonInterface.encodeFunctionData('deploy', [call.data, toBeHex(0, 32)])\n  }\n}\n\nexport function callToTuple(call: Call): [string, string, string] {\n  return [call.to, call.value.toString(), call.data]\n}\n\nexport function canBroadcast(op: AccountOp, accountIsEOA: boolean): boolean {\n  if (op.signingKeyAddr === null) throw new Error('missing signingKeyAddr')\n  if (op.signature === null) throw new Error('missing signature')\n  if (op.gasFeePayment === null) throw new Error('missing gasFeePayment')\n  if (op.gasLimit === null) throw new Error('missing gasLimit')\n  if (op.nonce === null) throw new Error('missing nonce')\n  if (accountIsEOA) {\n    if (op.gasFeePayment.isGasTank)\n      throw new Error('gas fee payment with gas tank cannot be used with an EOA')\n    if (op.gasFeePayment.inToken !== '0x0000000000000000000000000000000000000000')\n      throw new Error('gas fee payment needs to be in the native asset')\n    if (op.gasFeePayment.paidBy !== op.accountAddr)\n      throw new Error('gas fee payment cannot be paid by anyone other than the EOA that signed it')\n  }\n  return true\n}\n\n/**\n * Compare two AccountOps intents.\n *\n * By 'intent,' we are referring to the sender of the transaction, the network it is sent on, and the included calls.\n *\n * Since we are comparing the intents, we exclude any other properties of the AccountOps.\n */\nexport function isAccountOpsIntentEqual(\n  accountOps1: AccountOp[],\n  accountOps2: AccountOp[]\n): boolean {\n  const createIntent = (accountOps: AccountOp[]) => {\n    return accountOps.map(({ accountAddr, networkId, calls }) => ({\n      accountAddr,\n      networkId,\n      calls\n    }))\n  }\n\n  return stringify(createIntent(accountOps1)) === stringify(createIntent(accountOps2))\n}\n\nexport function getSignableCalls(op: AccountOp): [string, string, string][] {\n  const callsToSign = op.calls.map(toSingletonCall).map(callToTuple)\n  if (op.activatorCall) callsToSign.push(callToTuple(op.activatorCall))\n  if (op.feeCall) callsToSign.push(callToTuple(op.feeCall))\n  return callsToSign\n}\n\nexport function getSignableCallsForBundlerEstimate(op: AccountOp): [string, string, string][] {\n  const callsToSign = getSignableCalls(op)\n  // add the fee call one more time when doing a bundler estimate\n  // this is because the feeCall during estimation is fake (approve instead\n  // of transfer, incorrect amount) and more ofteh than not, this causes\n  // a lower estimation than the real one, causing bad UX in the process\n  if (op.feeCall) callsToSign.push(callToTuple(op.feeCall))\n  return callsToSign\n}\n\nexport function getSignableHash(\n  addr: AccountId,\n  chainId: bigint,\n  nonce: bigint,\n  calls: [string, string, string][]\n): Uint8Array {\n  const abiCoder = new AbiCoder()\n  return getBytes(\n    keccak256(\n      abiCoder.encode(\n        ['address', 'uint', 'uint', 'tuple(address, uint, bytes)[]'],\n        [addr, chainId, nonce, calls]\n      )\n    )\n  )\n}\n\n/**\n * This function returns the hash as a Uint8Array instead of string\n * and the reason for this is the implementation that follows:\n *\n * const hash = accountOpSignableHash(op); // get the hash\n * const signature = await wallet.signMessage(hash)\n *\n * The signMessage method is an ethers method. It checks whether\n * the hash is a string or not. If it's a string, it calls\n * ethers.toUtf8Bytes to it, completing ignoring that the string\n * might actually be abi-encoded (like in our case).\n *\n * Applying ethers.toUtf8Bytes to a string is only correct if the\n * string is... a utf8 string. In our case, IT IS NOT.\n * That's why we need to wrap in with ethers.getBytes to prevent\n * the sign message from breaking it.\n *\n * If despite everything you wish to return a string instead of a Uint8Array,\n * you have to wrap the hash with ethers.getBytes each time before passing it\n * to signMessage. Also, the reverse method of ethers.getBytes is ethers.hexlify\n * if you need to transform it back.\n *\n * @param op AccountOp\n * @returns Uint8Array\n */\nexport function accountOpSignableHash(op: AccountOp, chainId: bigint): Uint8Array {\n  return getSignableHash(op.accountAddr, chainId, op.nonce ?? 0n, getSignableCalls(op))\n}\n"]}