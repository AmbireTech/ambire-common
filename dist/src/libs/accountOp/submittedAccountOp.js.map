{"version":3,"file":"submittedAccountOp.js","sourceRoot":"","sources":["../../../../src/libs/accountOp/submittedAccountOp.ts"],"names":[],"mappings":"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","sourcesContent":["import { TransactionReceipt, ZeroAddress } from 'ethers'\n\nimport { BUNDLER } from '../../consts/bundlers'\nimport { Fetch } from '../../interfaces/fetch'\nimport { Network } from '../../interfaces/network'\nimport { getBundlerByName, getDefaultBundler } from '../../services/bundlers/getBundler'\nimport { fetchUserOp } from '../../services/explorers/jiffyscan'\nimport wait from '../../utils/wait'\nimport { AccountOp } from './accountOp'\nimport { AccountOpStatus, Call } from './types'\n\n/*\n * AccountOpIdentifiedBy\n * The txnId may not neceseraly be final on the moment of broadcast.\n * It is final when the type is Transaction. This is the case when we do\n * a regular EOA broadcast (including SA EOA broadcast)\n * The relayer and bundler work differently, though. The relayer may sometimes\n * decide not to return a txnId at all if it decides the current gas prices\n * are too high for the transaction. Also, it may return a txnId only to\n * replace it with another if the conditions meet. Here is an example:\n * - you broadcast a transaction on slow and the relayer returns a txnId\n * - at the same time another person broadcasts via the relayer, fast speed\n * - the relayer sees- that the second txn's chances of getting confirmed sooner\n * are higher and replaces the current one with the RBF logic\n * - at a later stage, the relayer re-broadcasts the first txn but since it's\n * a different nonce and signature, the txnId also differs\n * That's why we cannot rely on txnId for smart accounts in the relayer\n * broadcast case to fetch information about the transaction. Instead, the\n * relayer will return a database ID record of the transaction and we will be\n * refetching the txnId from the relayer until the transaction gets mined.\n *\n * The same logic is true for userOps and bundler broadcast. In the case of\n * userOps, the only difference is that we get a userOpHash instead of a\n * database ID record\n */\nexport type AccountOpIdentifiedBy = {\n  type: 'Transaction' | 'UserOperation' | 'Relayer' | 'MultipleTxns'\n  identifier: string\n  bundler?: BUNDLER\n}\n\nexport interface SubmittedAccountOp extends AccountOp {\n  txnId?: string\n  nonce: bigint\n  success?: boolean\n  timestamp: number\n  isSingletonDeploy?: boolean\n  identifiedBy: AccountOpIdentifiedBy\n}\n\nexport function isIdentifiedByTxn(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy && identifiedBy.type === 'Transaction'\n}\n\nexport function isIdentifiedByUserOpHash(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy && identifiedBy.type === 'UserOperation'\n}\n\nexport function isIdentifiedByRelayer(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy && identifiedBy.type === 'Relayer'\n}\n\nexport function isIdentifiedByMultipleTxn(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy && identifiedBy.type === 'MultipleTxns'\n}\n\nexport function getDappIdentifier(op: SubmittedAccountOp) {\n  let hash = `${op.identifiedBy.type}:${op.identifiedBy.identifier}`\n  if (op.identifiedBy?.bundler) hash = `${hash}:${op.identifiedBy.bundler}`\n  return hash\n}\n\nexport function getMultipleBroadcastUnconfirmedCallOrLast(op: AccountOp): {\n  call: Call\n  callIndex: number\n} {\n  // get the first BroadcastedButNotConfirmed call if any\n  for (let i = 0; i < op.calls.length; i++) {\n    const currentCall = op.calls[i]\n    if (currentCall.status === AccountOpStatus.BroadcastedButNotConfirmed)\n      return { call: currentCall, callIndex: i }\n  }\n\n  // if no BroadcastedButNotConfirmed, get the last one\n  return { call: op.calls[op.calls.length - 1], callIndex: op.calls.length - 1 }\n}\n\nexport async function fetchFrontRanTxnId(\n  identifiedBy: AccountOpIdentifiedBy,\n  foundTxnId: string,\n  network: Network,\n  counter = 0\n): Promise<string> {\n  // try to find the probably front ran txn id 5 times and if it can't,\n  // return the already found one. It could've really failed\n  if (counter >= 5) return foundTxnId\n\n  const userOpHash = identifiedBy.identifier\n  const bundler = identifiedBy.bundler\n    ? getBundlerByName(identifiedBy.bundler)\n    : getDefaultBundler(network)\n  const bundlerResult = await bundler.getStatus(network, userOpHash)\n  if (\n    !bundlerResult.transactionHash ||\n    bundlerResult.transactionHash.toLowerCase() === foundTxnId.toLowerCase()\n  ) {\n    await wait(2000)\n    return fetchFrontRanTxnId(identifiedBy, foundTxnId, network, counter + 1)\n  }\n\n  return bundlerResult.transactionHash\n}\n\nexport async function fetchTxnId(\n  identifiedBy: AccountOpIdentifiedBy,\n  network: Network,\n  fetchFn: Fetch,\n  callRelayer: Function,\n  op?: AccountOp\n): Promise<{ status: string; txnId: string | null }> {\n  if (isIdentifiedByTxn(identifiedBy))\n    return {\n      status: 'success',\n      txnId: identifiedBy.identifier\n    }\n\n  if (isIdentifiedByMultipleTxn(identifiedBy)) {\n    if (op) {\n      return {\n        status: 'success',\n        txnId: getMultipleBroadcastUnconfirmedCallOrLast(op).call.txnId as string\n      }\n    }\n\n    // always return the last txn id if no account op\n    const txnIds = identifiedBy.identifier.split('-')\n    return {\n      status: 'success',\n      txnId: txnIds[txnIds.length - 1]\n    }\n  }\n\n  if (isIdentifiedByUserOpHash(identifiedBy)) {\n    const userOpHash = identifiedBy.identifier\n\n    const bundler = identifiedBy.bundler\n      ? getBundlerByName(identifiedBy.bundler)\n      : getDefaultBundler(network)\n\n    const [response, bundlerResult]: [any, any] = await Promise.all([\n      fetchUserOp(userOpHash, fetchFn),\n      bundler.getStatus(network, userOpHash)\n    ])\n\n    if (bundlerResult.status === 'rejected')\n      return {\n        status: 'rejected',\n        txnId: null\n      }\n\n    if (bundlerResult.transactionHash)\n      return {\n        status: 'success',\n        txnId: bundlerResult.transactionHash\n      }\n\n    // on custom networks the response is null\n    if (!response)\n      return {\n        status: 'not_found',\n        txnId: null\n      }\n\n    // nothing we can do if we don't have information\n    if (response.status !== 200)\n      return {\n        status: 'not_found',\n        txnId: null\n      }\n\n    const data = await response.json()\n    const userOps = data.userOps\n\n    // if there are not user ops, it means the userOpHash is not\n    // indexed, yet, so we wait\n    if (userOps.length)\n      return {\n        status: 'success',\n        txnId: userOps[0].transactionHash\n      }\n\n    return {\n      status: 'not_found',\n      txnId: null\n    }\n  }\n\n  const id = identifiedBy.identifier\n  let response = null\n  try {\n    response = await callRelayer(`/v2/get-txn-id/${id}`)\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.log(`relayer responded with an error when trying to find the txnId: ${e}`)\n    return {\n      status: 'not_found',\n      txnId: null\n    }\n  }\n\n  if (!response.data.txId) {\n    if (op && op.txnId)\n      return {\n        status: 'success',\n        txnId: op.txnId\n      }\n    return {\n      status: 'not_found',\n      txnId: null\n    }\n  }\n\n  return {\n    status: 'success',\n    txnId: response.data.txId\n  }\n}\n\nexport function updateOpStatus(\n  // IMPORTANT: pass a reference to this.#accountsOps[accAddr][chainId][index]\n  // so we could mutate it from inside this method\n  opReference: SubmittedAccountOp,\n  status: AccountOpStatus,\n  receipt?: TransactionReceipt\n): SubmittedAccountOp | null {\n  if (opReference.identifiedBy.type === 'MultipleTxns') {\n    const callIndex = getMultipleBroadcastUnconfirmedCallOrLast(opReference).callIndex\n    // eslint-disable-next-line no-param-reassign\n    opReference.calls[callIndex].status = status\n\n    // if there's a receipt, add the fee\n    if (receipt) {\n      // eslint-disable-next-line no-param-reassign\n      opReference.calls[callIndex].fee = {\n        inToken: ZeroAddress,\n        amount: receipt.fee\n      }\n    }\n\n    if (callIndex === opReference.calls.length - 1) {\n      // eslint-disable-next-line no-param-reassign\n      opReference.status = status\n      return opReference\n    }\n\n    // returning null here means the accountOp as a whole is still not ready\n    // to be updated as there are still pending transaction to be confirmed\n    return null\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  opReference.status = status\n  return opReference\n}\n"]}