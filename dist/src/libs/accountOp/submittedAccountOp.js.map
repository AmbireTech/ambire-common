{"version":3,"file":"submittedAccountOp.js","sourceRoot":"","sources":["../../../../src/libs/accountOp/submittedAccountOp.ts"],"names":[],"mappings":"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","sourcesContent":["import { BUNDLER } from '../../consts/bundlers'\nimport { Fetch } from '../../interfaces/fetch'\nimport { Network } from '../../interfaces/network'\nimport { getBundlerByName, getDefaultBundler } from '../../services/bundlers/getBundler'\nimport { fetchUserOp } from '../../services/explorers/jiffyscan'\nimport { AccountOp } from './accountOp'\n\n/*\n * AccountOpIdentifiedBy\n * The txnId may not neceseraly be final on the moment of broadcast.\n * It is final when the type is Transaction. This is the case when we do\n * a regular EOA broadcast (including SA EOA broadcast)\n * The relayer and bundler work differently, though. The relayer may sometimes\n * decide not to return a txnId at all if it decides the current gas prices\n * are too high for the transaction. Also, it may return a txnId only to\n * replace it with another if the conditions meet. Here is an example:\n * - you broadcast a transaction on slow and the relayer returns a txnId\n * - at the same time another person broadcasts via the relayer, fast speed\n * - the relayer sees- that the second txn's chances of getting confirmed sooner\n * are higher and replaces the current one with the RBF logic\n * - at a later stage, the relayer re-broadcasts the first txn but since it's\n * a different nonce and signature, the txnId also differs\n * That's why we cannot rely on txnId for smart accounts in the relayer\n * broadcast case to fetch information about the transaction. Instead, the\n * relayer will return a database ID record of the transaction and we will be\n * refetching the txnId from the relayer until the transaction gets mined.\n *\n * The same logic is true for userOps and bundler broadcast. In the case of\n * userOps, the only difference is that we get a userOpHash instead of a\n * database ID record\n */\nexport type AccountOpIdentifiedBy = {\n  type: 'Transaction' | 'UserOperation' | 'Relayer'\n  identifier: string\n  bundler?: BUNDLER\n}\n\nexport interface SubmittedAccountOp extends AccountOp {\n  txnId?: string\n  nonce: bigint\n  success?: boolean\n  timestamp: number\n  isSingletonDeploy?: boolean\n  identifiedBy: AccountOpIdentifiedBy\n  flags?: {\n    hideActivityBanner?: boolean\n  }\n}\n\nexport function isIdentifiedByTxn(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy.type === 'Transaction'\n}\n\nexport function isIdentifiedByUserOpHash(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy.type === 'UserOperation'\n}\n\nexport function isIdentifiedByRelayer(identifiedBy: AccountOpIdentifiedBy): boolean {\n  return identifiedBy.type === 'Relayer'\n}\n\nexport function getDappIdentifier(op: SubmittedAccountOp) {\n  let hash = `${op.identifiedBy.type}:${op.identifiedBy.identifier}`\n  if (op.identifiedBy?.bundler) hash = `${hash}:${op.identifiedBy.bundler}`\n  return hash\n}\n\nexport async function fetchTxnId(\n  identifiedBy: AccountOpIdentifiedBy,\n  network: Network,\n  fetchFn: Fetch,\n  callRelayer: Function,\n  op?: AccountOp\n): Promise<{ status: string; txnId: string | null }> {\n  if (isIdentifiedByTxn(identifiedBy))\n    return {\n      status: 'success',\n      txnId: identifiedBy.identifier\n    }\n\n  if (isIdentifiedByUserOpHash(identifiedBy)) {\n    const userOpHash = identifiedBy.identifier\n\n    const bundler = identifiedBy.bundler\n      ? getBundlerByName(identifiedBy.bundler)\n      : getDefaultBundler(network)\n\n    const [response, bundlerResult]: [any, any] = await Promise.all([\n      fetchUserOp(userOpHash, fetchFn),\n      bundler.getStatus(network, userOpHash)\n    ])\n\n    if (bundlerResult.status === 'rejected')\n      return {\n        status: 'rejected',\n        txnId: null\n      }\n\n    if (bundlerResult.transactionHash)\n      return {\n        status: 'success',\n        txnId: bundlerResult.transactionHash\n      }\n\n    // on custom networks the response is null\n    if (!response)\n      return {\n        status: 'not_found',\n        txnId: null\n      }\n\n    // nothing we can do if we don't have information\n    if (response.status !== 200)\n      return {\n        status: 'not_found',\n        txnId: null\n      }\n\n    const data = await response.json()\n    const userOps = data.userOps\n\n    // if there are not user ops, it means the userOpHash is not\n    // indexed, yet, so we wait\n    if (userOps.length)\n      return {\n        status: 'success',\n        txnId: userOps[0].transactionHash\n      }\n\n    return {\n      status: 'not_found',\n      txnId: null\n    }\n  }\n\n  const id = identifiedBy.identifier\n  let response = null\n  try {\n    response = await callRelayer(`/v2/get-txn-id/${id}`)\n  } catch (e) {\n    console.log(`relayer responded with an error when trying to find the txnId: ${e}`)\n    return {\n      status: 'not_found',\n      txnId: null\n    }\n  }\n\n  if (!response.data.txId) {\n    if (op && op.txnId)\n      return {\n        status: 'success',\n        txnId: op.txnId\n      }\n    return {\n      status: 'not_found',\n      txnId: null\n    }\n  }\n\n  return {\n    status: 'success',\n    txnId: response.data.txId\n  }\n}\n\nexport async function pollTxnId(\n  identifiedBy: AccountOpIdentifiedBy,\n  network: Network,\n  fetchFn: Fetch,\n  callRelayer: Function,\n  failCount = 0\n): Promise<string | null> {\n  // allow 8 retries and declate fetching the txnId a failure after\n  if (failCount >= 8) return null\n\n  const fetchTxnIdResult = await fetchTxnId(identifiedBy, network, fetchFn, callRelayer)\n  if (fetchTxnIdResult.status === 'rejected') return null\n\n  if (fetchTxnIdResult.status === 'not_found') {\n    const delayPromise = () =>\n      new Promise((resolve) => {\n        setTimeout(resolve, 1500)\n      })\n    await delayPromise()\n    const increase = failCount + 1\n    return pollTxnId(identifiedBy, network, fetchFn, callRelayer, increase)\n  }\n\n  return fetchTxnIdResult.txnId\n}\n"]}