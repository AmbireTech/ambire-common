{"version":3,"file":"keyIterator.js","sourceRoot":"","sources":["../../../../src/libs/keyIterator/keyIterator.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable new-cap */\nimport { HDNodeWallet, Mnemonic, Wallet } from 'ethers'\n\nimport {\n  HD_PATH_TEMPLATE_TYPE,\n  SMART_ACCOUNT_SIGNER_KEY_DERIVATION_OFFSET\n} from '../../consts/derivation'\nimport { SelectedAccountForImport } from '../../interfaces/account'\nimport { KeyIterator as KeyIteratorInterface } from '../../interfaces/keyIterator'\nimport { Key } from '../../interfaces/keystore'\nimport { getHdPathFromTemplate } from '../../utils/hdPath'\nimport { isDerivedForSmartAccountKeyOnly } from '../account/account'\nimport { getDefaultKeyLabel, getExistingKeyLabel } from '../keys/keys'\n\nexport function isValidPrivateKey(value: string): boolean {\n  try {\n    return !!new Wallet(value)\n  } catch {\n    return false\n  }\n}\n\nexport const getPrivateKeyFromSeed = (\n  seed: string,\n  seedPassphrase: string | null | undefined,\n  keyIndex: number,\n  hdPathTemplate: HD_PATH_TEMPLATE_TYPE\n) => {\n  const mnemonic = Mnemonic.fromPhrase(seed, seedPassphrase)\n  const wallet = HDNodeWallet.fromMnemonic(\n    mnemonic,\n    getHdPathFromTemplate(hdPathTemplate, keyIndex)\n  )\n  if (wallet) {\n    return wallet.privateKey\n  }\n\n  throw new Error('Getting the private key from the seed phrase failed.')\n}\n\n/**\n * Serves for retrieving a range of addresses/keys from a given private key or seed phrase\n */\nexport class KeyIterator implements KeyIteratorInterface {\n  type = 'internal' as 'internal'\n\n  subType: 'seed' | 'private-key'\n\n  #privateKey: string | null = null\n\n  #seedPhrase: string | null = null\n\n  #seedPassphrase: string | null = null\n\n  constructor(_privKeyOrSeed: string, _seedPassphrase?: string | null) {\n    if (!_privKeyOrSeed) throw new Error('keyIterator: no private key or seed phrase provided')\n\n    if (isValidPrivateKey(_privKeyOrSeed)) {\n      this.#privateKey = _privKeyOrSeed\n      this.subType = 'private-key'\n      return\n    }\n\n    if (Mnemonic.isValidMnemonic(_privKeyOrSeed)) {\n      this.#seedPhrase = _privKeyOrSeed\n      this.subType = 'seed'\n\n      if (_seedPassphrase) {\n        this.#seedPassphrase = _seedPassphrase\n      }\n      return\n    }\n\n    throw new Error('keyIterator: invalid argument provided to constructor')\n  }\n\n  async getEncryptedSeed(\n    encryptor: (\n      seed: string,\n      seedPassphrase?: string | null | undefined\n    ) => Promise<{\n      seed: string\n      passphrase: string | null\n    }>\n  ) {\n    if (!this.#seedPhrase) return null\n    const encryptedSeed = await encryptor(this.#seedPhrase, this.#seedPassphrase)\n\n    return encryptedSeed\n  }\n\n  async retrieve(\n    fromToArr: { from: number; to: number }[],\n    hdPathTemplate?: HD_PATH_TEMPLATE_TYPE\n  ) {\n    const keys: string[] = []\n\n    fromToArr.forEach(({ from, to }) => {\n      if ((!from && from !== 0) || (!to && to !== 0) || !hdPathTemplate)\n        throw new Error('keyIterator: invalid or missing arguments')\n\n      if (this.#privateKey) {\n        const shouldDerive = from >= SMART_ACCOUNT_SIGNER_KEY_DERIVATION_OFFSET\n        // Before v4.31.0, private keys for accounts used as smart account keys\n        // were derived. That's no longer the case. Importing private keys\n        // does not generate smart accounts anymore.\n        if (!shouldDerive) keys.push(new Wallet(this.#privateKey).address)\n      }\n\n      if (this.#seedPhrase) {\n        const mnemonic = Mnemonic.fromPhrase(this.#seedPhrase, this.#seedPassphrase)\n\n        for (let i = from; i <= to; i++) {\n          const wallet = HDNodeWallet.fromMnemonic(\n            mnemonic,\n            getHdPathFromTemplate(hdPathTemplate, i)\n          )\n          keys.push(wallet.address)\n        }\n      }\n    })\n\n    return keys\n  }\n\n  retrieveInternalKeys(\n    selectedAccountsForImport: SelectedAccountForImport[],\n    hdPathTemplate: HD_PATH_TEMPLATE_TYPE,\n    keystoreKeys: Key[]\n  ) {\n    return selectedAccountsForImport.flatMap((acc) => {\n      // Should never happen\n      if (!['seed', 'private-key'].includes(this.subType)) {\n        console.error('keyIterator: invalid subType', this.subType)\n        return []\n      }\n\n      return acc.accountKeys.flatMap(({ index }: { index: number }, i) => {\n        // In case it is a seed, the private keys have to be extracted\n        if (this.subType === 'seed') {\n          if (!this.#seedPhrase) {\n            // Should never happen\n            console.error('keyIterator: no seed phrase provided')\n            return []\n          }\n\n          const privateKey = getPrivateKeyFromSeed(\n            this.#seedPhrase,\n            this.#seedPassphrase,\n            index,\n            hdPathTemplate\n          )\n          return [\n            {\n              addr: new Wallet(privateKey).address,\n              type: 'internal' as 'internal',\n              label:\n                getExistingKeyLabel(keystoreKeys, acc.account.addr, this.type) ||\n                getDefaultKeyLabel(\n                  keystoreKeys.filter((key) => acc.account.associatedKeys.includes(key.addr)),\n                  i\n                ),\n              privateKey,\n              dedicatedToOneSA: isDerivedForSmartAccountKeyOnly(index),\n              meta: {\n                createdAt: new Date().getTime()\n              }\n            }\n          ]\n        }\n\n        // So the subType is 'private-key' then\n        if (!this.#privateKey) {\n          // Should never happen\n          console.error('keyIterator: no private key provided')\n          return []\n        }\n\n        // Before v4.31.0, private keys for accounts used as smart account keys\n        // were derived. That's no longer the case. Importing private keys\n        // does not generate smart accounts anymore.\n        const isPrivateKeyThatShouldBeDerived =\n          isValidPrivateKey(this.#privateKey) && index >= SMART_ACCOUNT_SIGNER_KEY_DERIVATION_OFFSET\n        if (isPrivateKeyThatShouldBeDerived) {\n          // Should never happen\n          console.error(\n            'keyIterator: since v4.31.0, private keys should not be derived and importing them does not retrieve a smart account'\n          )\n          return []\n        }\n\n        return [\n          {\n            addr: new Wallet(this.#privateKey).address,\n            type: 'internal' as 'internal',\n            label:\n              getExistingKeyLabel(keystoreKeys, acc.account.addr, this.type) ||\n              getDefaultKeyLabel(\n                keystoreKeys.filter((key) => acc.account.associatedKeys.includes(key.addr)),\n                0\n              ),\n            privateKey: this.#privateKey,\n            dedicatedToOneSA: false,\n            meta: {\n              createdAt: new Date().getTime()\n            }\n          }\n        ]\n      })\n    })\n  }\n\n  isSeedMatching(seedPhraseToCompareWith: string) {\n    if (!this.#seedPhrase) return false\n\n    return (\n      Mnemonic.fromPhrase(this.#seedPhrase).phrase ===\n      Mnemonic.fromPhrase(seedPhraseToCompareWith).phrase\n    )\n  }\n}\n"]}