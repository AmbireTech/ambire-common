{"version":3,"file":"userRequest.js","sourceRoot":"","sources":["../../../../src/libs/transfer/userRequest.ts"],"names":[],"mappings":"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","sourcesContent":["import { Interface, parseUnits } from 'ethers'\n\nimport IERC20 from '../../../contracts/compiled/IERC20.json'\nimport WALLETSupplyControllerABI from '../../../contracts/compiled/WALLETSupplyController.json'\nimport WETH from '../../../contracts/compiled/WETH.json'\nimport { FEE_COLLECTOR, STK_WALLET, SUPPLY_CONTROLLER_ADDR } from '../../consts/addresses'\nimport { networks } from '../../consts/networks'\nimport { Calls, SignUserRequest } from '../../interfaces/userRequest'\nimport { PaymasterService } from '../erc7677/types'\nimport { AddrVestingData, ClaimableRewardsData, TokenResult } from '../portfolio'\nimport { getSanitizedAmount } from './amount'\n\nconst ERC20 = new Interface(IERC20.abi)\nconst supplyControllerInterface = new Interface(WALLETSupplyControllerABI)\n\ninterface BuildUserRequestParams {\n  amount: string\n  selectedToken: TokenResult\n  selectedAccount: string\n  recipientAddress: string\n  paymasterService?: PaymasterService\n}\n\nfunction buildMintVestingRequest({\n  selectedAccount,\n  selectedToken,\n  addrVestingData\n}: {\n  selectedAccount: string\n  selectedToken: TokenResult\n  addrVestingData: AddrVestingData\n}): SignUserRequest {\n  const txn = {\n    kind: 'calls' as Calls['kind'],\n    calls: [\n      {\n        to: SUPPLY_CONTROLLER_ADDR,\n        value: BigInt(0),\n        data: supplyControllerInterface.encodeFunctionData('mintVesting', [\n          addrVestingData?.addr,\n          addrVestingData?.end,\n          addrVestingData?.rate\n        ])\n      }\n    ]\n  }\n  return {\n    id: new Date().getTime(),\n    action: txn,\n    meta: {\n      isSignAction: true,\n      chainId: selectedToken.chainId,\n      accountAddr: selectedAccount\n    }\n  }\n}\n\nfunction buildClaimWalletRequest({\n  selectedAccount,\n  selectedToken,\n  claimableRewardsData\n}: {\n  selectedAccount: string\n  selectedToken: TokenResult\n  claimableRewardsData: ClaimableRewardsData\n}): SignUserRequest {\n  const txn = {\n    kind: 'calls' as Calls['kind'],\n    calls: [\n      {\n        to: SUPPLY_CONTROLLER_ADDR,\n        value: BigInt(0),\n        data: supplyControllerInterface.encodeFunctionData('claimWithRootUpdate', [\n          claimableRewardsData?.totalClaimable,\n          claimableRewardsData?.proof,\n          0, // penalty bps, at the moment we run with 0; it's a safety feature to hardcode it\n          STK_WALLET, // staking pool addr\n          claimableRewardsData?.root,\n          claimableRewardsData?.signedRoot\n        ])\n      }\n    ]\n  }\n  return {\n    id: new Date().getTime(),\n    action: txn,\n    meta: {\n      isSignAction: true,\n      chainId: selectedToken.chainId,\n      accountAddr: selectedAccount\n    }\n  }\n}\n\nfunction buildTransferUserRequest({\n  amount,\n  selectedToken,\n  selectedAccount,\n  recipientAddress: _recipientAddress,\n  paymasterService\n}: BuildUserRequestParams): SignUserRequest | null {\n  if (!selectedToken || !selectedAccount || !_recipientAddress) return null\n\n  // if the request is a top up, the recipient is the relayer\n  const recipientAddress = _recipientAddress?.toLowerCase()\n  const sanitizedAmount = getSanitizedAmount(amount, selectedToken.decimals)\n\n  const bigNumberHexAmount = `0x${parseUnits(\n    sanitizedAmount,\n    Number(selectedToken.decimals)\n  ).toString(16)}`\n\n  // if the top up is a native one, we should wrap the native before sending it\n  // as otherwise a Transfer event is not emitted and the top up will not be\n  // recorded\n  const isNativeTopUp =\n    Number(selectedToken.address) === 0 &&\n    recipientAddress.toLowerCase() === FEE_COLLECTOR.toLowerCase()\n\n  if (isNativeTopUp) {\n    // if not predefined network, we cannot make a native top up\n    const network = networks.find((n) => n.chainId === selectedToken.chainId)\n    if (!network) return null\n\n    // if a wrapped addr is not specified, we cannot make a native top up\n    const wrappedAddr = network.wrappedAddr\n    if (!wrappedAddr) return null\n\n    const wrapped = new Interface(WETH)\n    const deposit = wrapped.encodeFunctionData('deposit')\n    const calls: Calls = {\n      kind: 'calls' as const,\n      calls: [\n        {\n          to: wrappedAddr,\n          value: BigInt(bigNumberHexAmount),\n          data: deposit\n        },\n        {\n          to: wrappedAddr,\n          value: BigInt(0),\n          data: ERC20.encodeFunctionData('transfer', [recipientAddress, bigNumberHexAmount])\n        }\n      ]\n    }\n\n    return {\n      id: new Date().getTime(),\n      action: calls,\n      meta: {\n        isSignAction: true,\n        chainId: selectedToken.chainId,\n        accountAddr: selectedAccount,\n        paymasterService\n      }\n    }\n  }\n\n  const txn = {\n    kind: 'calls' as const,\n    calls: [\n      {\n        to: selectedToken.address,\n        value: BigInt(0),\n        data: ERC20.encodeFunctionData('transfer', [recipientAddress, bigNumberHexAmount])\n      }\n    ]\n  }\n\n  if (Number(selectedToken.address) === 0) {\n    txn.calls = [\n      {\n        to: recipientAddress,\n        value: BigInt(bigNumberHexAmount),\n        data: '0x'\n      }\n    ]\n  }\n\n  return {\n    id: new Date().getTime(),\n    action: txn,\n    meta: {\n      isSignAction: true,\n      chainId: selectedToken.chainId,\n      accountAddr: selectedAccount,\n      paymasterService\n    }\n  }\n}\n\nexport { buildClaimWalletRequest, buildMintVestingRequest, buildTransferUserRequest }\n"]}