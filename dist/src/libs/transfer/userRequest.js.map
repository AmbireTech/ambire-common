{"version":3,"file":"userRequest.js","sourceRoot":"","sources":["../../../../src/libs/transfer/userRequest.ts"],"names":[],"mappings":"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","sourcesContent":["import { Interface, parseUnits } from 'ethers'\n\nimport IERC20 from '../../../contracts/compiled/IERC20.json'\nimport WALLETSupplyControllerABI from '../../../contracts/compiled/WALLETSupplyController.json'\nimport WETH from '../../../contracts/compiled/WETH.json'\nimport { FEE_COLLECTOR, SUPPLY_CONTROLLER_ADDR, WALLET_STAKING_ADDR } from '../../consts/addresses'\nimport { networks } from '../../consts/networks'\nimport { Calls, SignUserRequest } from '../../interfaces/userRequest'\nimport { AddrVestingData, ClaimableRewardsData, TokenResult } from '../portfolio'\nimport { getSanitizedAmount } from './amount'\n\nconst ERC20 = new Interface(IERC20.abi)\nconst supplyControllerInterface = new Interface(WALLETSupplyControllerABI)\n\ninterface BuildUserRequestParams {\n  amount: string\n  selectedToken: TokenResult\n  selectedAccount: string\n  recipientAddress: string\n}\n\nfunction buildMintVestingRequest({\n  selectedAccount,\n  selectedToken,\n  addrVestingData\n}: {\n  selectedAccount: string\n  selectedToken: TokenResult\n  addrVestingData: AddrVestingData\n}): SignUserRequest {\n  const txn = {\n    kind: 'calls' as Calls['kind'],\n    calls: [\n      {\n        to: SUPPLY_CONTROLLER_ADDR,\n        value: BigInt(0),\n        data: supplyControllerInterface.encodeFunctionData('mintVesting', [\n          addrVestingData?.addr,\n          addrVestingData?.end,\n          addrVestingData?.rate\n        ])\n      }\n    ]\n  }\n  return {\n    id: new Date().getTime(),\n    action: txn,\n    meta: {\n      isSignAction: true,\n      networkId: selectedToken.networkId,\n      accountAddr: selectedAccount\n    }\n  }\n}\n\nfunction buildClaimWalletRequest({\n  selectedAccount,\n  selectedToken,\n  claimableRewardsData\n}: {\n  selectedAccount: string\n  selectedToken: TokenResult\n  claimableRewardsData: ClaimableRewardsData\n}): SignUserRequest {\n  const txn = {\n    kind: 'calls' as Calls['kind'],\n    calls: [\n      {\n        to: SUPPLY_CONTROLLER_ADDR,\n        value: BigInt(0),\n        data: supplyControllerInterface.encodeFunctionData('claimWithRootUpdate', [\n          claimableRewardsData?.totalClaimable,\n          claimableRewardsData?.proof,\n          0, // penalty bps, at the moment we run with 0; it's a safety feature to hardcode it\n          WALLET_STAKING_ADDR, // staking pool addr\n          claimableRewardsData?.root,\n          claimableRewardsData?.signedRoot\n        ])\n      }\n    ]\n  }\n  return {\n    id: new Date().getTime(),\n    action: txn,\n    meta: {\n      isSignAction: true,\n      networkId: selectedToken.networkId,\n      accountAddr: selectedAccount\n    }\n  }\n}\n\nfunction buildTransferUserRequest({\n  amount,\n  selectedToken,\n  selectedAccount,\n  recipientAddress: _recipientAddress\n}: BuildUserRequestParams): SignUserRequest | null {\n  if (!selectedToken || !selectedAccount || !_recipientAddress) return null\n\n  // if the request is a top up, the recipient is the relayer\n  const recipientAddress = _recipientAddress?.toLowerCase()\n  const sanitizedAmount = getSanitizedAmount(amount, selectedToken.decimals)\n\n  const bigNumberHexAmount = `0x${parseUnits(\n    sanitizedAmount,\n    Number(selectedToken.decimals)\n  ).toString(16)}`\n\n  // if the top up is a native one, we should wrap the native before sending it\n  // as otherwise a Transfer event is not emitted and the top up will not be\n  // recorded\n  const isNativeTopUp =\n    Number(selectedToken.address) === 0 &&\n    recipientAddress.toLowerCase() === FEE_COLLECTOR.toLowerCase()\n  if (isNativeTopUp) {\n    // if not predefined network, we cannot make a native top up\n    const network = networks.find((net) => net.id === selectedToken.networkId)\n    if (!network) return null\n\n    // if a wrapped addr is not specified, we cannot make a native top up\n    const wrappedAddr = network.wrappedAddr\n    if (!wrappedAddr) return null\n\n    const wrapped = new Interface(WETH)\n    const deposit = wrapped.encodeFunctionData('deposit')\n    const calls: Calls = {\n      kind: 'calls' as const,\n      calls: [\n        {\n          to: wrappedAddr,\n          value: BigInt(bigNumberHexAmount),\n          data: deposit\n        },\n        {\n          to: wrappedAddr,\n          value: BigInt(0),\n          data: ERC20.encodeFunctionData('transfer', [recipientAddress, bigNumberHexAmount])\n        }\n      ]\n    }\n    return {\n      id: new Date().getTime(),\n      action: calls,\n      meta: {\n        isSignAction: true,\n        networkId: selectedToken.networkId,\n        accountAddr: selectedAccount\n      }\n    }\n  }\n\n  const txn = {\n    kind: 'calls' as const,\n    calls: [\n      {\n        to: selectedToken.address,\n        value: BigInt(0),\n        data: ERC20.encodeFunctionData('transfer', [recipientAddress, bigNumberHexAmount])\n      }\n    ]\n  }\n\n  if (Number(selectedToken.address) === 0) {\n    txn.calls = [\n      {\n        to: recipientAddress,\n        value: BigInt(bigNumberHexAmount),\n        data: '0x'\n      }\n    ]\n  }\n\n  return {\n    id: new Date().getTime(),\n    action: txn,\n    meta: {\n      isSignAction: true,\n      networkId: selectedToken.networkId,\n      accountAddr: selectedAccount\n    }\n  }\n}\n\nexport { buildTransferUserRequest, buildClaimWalletRequest, buildMintVestingRequest }\n"]}