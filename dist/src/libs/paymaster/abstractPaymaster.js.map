{"version":3,"file":"abstractPaymaster.js","sourceRoot":"","sources":["../../../../src/libs/paymaster/abstractPaymaster.ts"],"names":[],"mappings":";;;AAaA;;GAEG;AACH,MAAsB,iBAAiB;IACrC;;;OAGG;IACH,qBAAqB,CAAqC;CA8B3D;AAnCD,8CAmCC","sourcesContent":["import { Account } from '../../interfaces/account'\nimport { Network } from '../../interfaces/network'\nimport { RPCProvider } from '../../interfaces/provider'\nimport { AccountOp } from '../accountOp/accountOp'\nimport { Call } from '../accountOp/types'\nimport {\n  PaymasterErrorReponse,\n  PaymasterEstimationData,\n  PaymasterSuccessReponse\n} from '../erc7677/types'\nimport { TokenResult } from '../portfolio'\nimport { UserOperation } from '../userOperation/types'\n\n/**\n * Use this mainly as a typehint to prevent dependancy cicles\n */\nexport abstract class AbstractPaymaster {\n  /**\n   * If there's a sponsorship from pm_getPaymasterStubData,\n   * it will get recorded here. Use it for the final broadcast\n   */\n  sponsorDataEstimation: PaymasterEstimationData | undefined\n\n  abstract init(\n    op: AccountOp,\n    userOp: UserOperation,\n    account: Account,\n    network: Network,\n    provider: RPCProvider\n  ): void\n\n  abstract shouldIncludePayment(): boolean\n\n  abstract getFeeCallType(feeTokens: TokenResult[]): string | undefined\n\n  abstract getFeeCallForEstimation(feeTokens: TokenResult[]): Call | undefined\n\n  abstract getEstimationData(): PaymasterEstimationData | null\n\n  abstract isSponsored(): boolean\n\n  abstract isUsable(): boolean\n\n  abstract canAutoRetryOnFailure(): boolean\n\n  abstract call(\n    acc: Account,\n    op: AccountOp,\n    userOp: UserOperation,\n    network: Network\n  ): Promise<PaymasterSuccessReponse | PaymasterErrorReponse>\n}\n"]}