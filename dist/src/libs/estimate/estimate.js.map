{"version":3,"file":"estimate.js","sourceRoot":"","sources":["../../../../src/libs/estimate/estimate.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbiCoder, ZeroAddress } from 'ethers'\n\nimport Estimation from '../../../contracts/compiled/Estimation.json'\nimport { FEE_COLLECTOR } from '../../consts/addresses'\nimport { DEPLOYLESS_SIMULATION_FROM, OPTIMISTIC_ORACLE } from '../../consts/deploy'\nimport { Account, AccountStates } from '../../interfaces/account'\nimport { Network } from '../../interfaces/network'\nimport { RPCProvider } from '../../interfaces/provider'\nimport { BundlerSwitcher } from '../../services/bundlers/bundlerSwitcher'\nimport { getAccountDeployParams, isSmartAccount } from '../account/account'\nimport { AccountOp, toSingletonCall } from '../accountOp/accountOp'\nimport { Call } from '../accountOp/types'\nimport { getFeeCall } from '../calls/calls'\nimport { fromDescriptor } from '../deployless/deployless'\nimport { InnerCallFailureError } from '../errorDecoder/customErrors'\nimport { getHumanReadableEstimationError } from '../errorHumanizer'\nimport { getProbableCallData } from '../gasPrice/gasPrice'\nimport { hasRelayerSupport } from '../networks/networks'\nimport { GasTankTokenResult, TokenResult } from '../portfolio'\nimport { getActivatorCall, shouldIncludeActivatorCall } from '../userOperation/userOperation'\nimport { estimationErrorFormatted } from './errors'\nimport { bundlerEstimate } from './estimateBundler'\nimport { estimateEOA } from './estimateEOA'\nimport { estimateGas } from './estimateGas'\nimport { getFeeTokenForEstimate } from './estimateHelpers'\nimport { estimateWithRetries } from './estimateWithRetries'\nimport { EstimateResult, FeePaymentOption } from './interfaces'\nimport { refund } from './refund'\n\nconst abiCoder = new AbiCoder()\n\nfunction getInnerCallFailure(\n  estimationOp: { success: boolean; err: string },\n  calls: Call[],\n  network: Network,\n  portfolioNativeValue?: bigint\n): Error | null {\n  if (estimationOp.success) return null\n\n  const error = getHumanReadableEstimationError(\n    new InnerCallFailureError(estimationOp.err, calls, network, portfolioNativeValue)\n  )\n\n  return new Error(error.message, {\n    cause: 'CALLS_FAILURE'\n  })\n}\n\n// the outcomeNonce should always be equal to the nonce in accountOp + 1\n// that's an indication of transaction success\nfunction getNonceDiscrepancyFailure(op: AccountOp, outcomeNonce: number): Error | null {\n  if (op.nonce !== null && op.nonce + 1n === BigInt(outcomeNonce)) return null\n\n  return new Error(\"Nonce discrepancy, perhaps there's a pending transaction. Retrying...\", {\n    cause: 'NONCE_FAILURE'\n  })\n}\n\nexport async function estimate4337(\n  account: Account,\n  op: AccountOp,\n  calls: Call[],\n  accountStates: AccountStates,\n  network: Network,\n  provider: RPCProvider,\n  feeTokens: TokenResult[],\n  blockTag: string | number,\n  nativeToCheck: string[],\n  switcher: BundlerSwitcher,\n  errorCallback: Function\n): Promise<EstimateResult> {\n  const deploylessEstimator = fromDescriptor(provider, Estimation, !network.rpcNoStateOverride)\n\n  // build the feePaymentOptions with the available current amounts. We will\n  // change them after simulation passes\n  let feePaymentOptions = feeTokens.map((token: TokenResult) => {\n    return {\n      paidBy: account.addr,\n      availableAmount: token.amount,\n      // @relyOnBundler\n      // gasUsed goes to 0\n      // we add a transfer call or a native call when sending the uOp to the\n      // bundler and he estimates that. For different networks this gasUsed\n      // goes to different places (callGasLimit or preVerificationGas) and\n      // its calculated differently. So it's a wild bet to think we could\n      // calculate this on our own for each network.\n      gasUsed: 0n,\n      // addedNative gets calculated by the bundler & added to uOp gasData\n      addedNative: 0n,\n      token\n    }\n  })\n\n  const accountState = accountStates[op.accountAddr][op.networkId]\n  const checkInnerCallsArgs = [\n    account.addr,\n    ...getAccountDeployParams(account),\n    [\n      account.addr,\n      op.accountOpToExecuteBefore?.nonce || 0,\n      op.accountOpToExecuteBefore?.calls || [],\n      op.accountOpToExecuteBefore?.signature || '0x'\n    ],\n    [account.addr, op.nonce || 1, calls, '0x'],\n    getProbableCallData(account, op, accountState, network),\n    account.associatedKeys,\n    feeTokens.map((feeToken) => feeToken.address),\n    FEE_COLLECTOR,\n    nativeToCheck,\n    network.isOptimistic ? OPTIMISTIC_ORACLE : ZeroAddress\n  ]\n\n  // always add a feeCall if available as we're using the paymaster\n  // on predefined chains and on custom networks it is better to\n  // have a slightly bigger estimation (if we don't have a paymaster)\n  const estimateGasOp = { ...op }\n  const feeToken = getFeeTokenForEstimate(feeTokens, network)\n  if (feeToken) estimateGasOp.feeCall = getFeeCall(feeToken)\n\n  const initializeRequests = () => [\n    deploylessEstimator\n      .call('estimate', checkInnerCallsArgs, {\n        from: DEPLOYLESS_SIMULATION_FROM,\n        blockTag\n      })\n      .catch(getHumanReadableEstimationError),\n    bundlerEstimate(\n      account,\n      accountStates,\n      op,\n      network,\n      feeTokens,\n      provider,\n      switcher,\n      errorCallback\n    ),\n    estimateGas(account, estimateGasOp, provider, accountState, network).catch(() => 0n)\n  ]\n  const estimations = await estimateWithRetries(\n    initializeRequests,\n    'estimation-deployless',\n    errorCallback,\n    12000\n  )\n\n  const ambireEstimation = estimations[0]\n  const bundlerEstimationResult: EstimateResult = estimations[1]\n  if (ambireEstimation instanceof Error) {\n    return estimationErrorFormatted(\n      // give priority to the bundler error if both estimations end up with an error\n      bundlerEstimationResult.error ?? ambireEstimation,\n      { feePaymentOptions }\n    )\n  }\n  // // if there's a bundler error only, remove the smart account payment options\n  // if (bundlerEstimationResult instanceof Error) feePaymentOptions = []\n  const [\n    [\n      deployment,\n      accountOpToExecuteBefore,\n      accountOp,\n      outcomeNonce,\n      feeTokenOutcomes,\n      ,\n      nativeAssetBalances,\n      ,\n      l1GasEstimation\n    ]\n  ] = estimations[0]\n  const ambireEstimationError =\n    getInnerCallFailure(\n      accountOp,\n      calls,\n      network,\n      feeTokens.find((token) => token.address === ZeroAddress && !token.flags.onGasTank)?.amount\n    ) || getNonceDiscrepancyFailure(op, outcomeNonce)\n\n  // if Estimation.sol estimate is a success, it means the nonce has incremented\n  // so we subtract 1 from it. If it's an error, we return the old one\n  bundlerEstimationResult.currentAccountNonce = accountOp.success\n    ? Number(outcomeNonce - 1n)\n    : Number(outcomeNonce)\n\n  if (ambireEstimationError) {\n    // if there's an ambire estimation error, we do not allow the txn\n    // to be executed as it means it will most certainly fail\n    bundlerEstimationResult.error = ambireEstimationError\n  } else if (!ambireEstimationError && bundlerEstimationResult.error) {\n    // if there's a bundler error only, it means it's a bundler specific\n    // problem. If we can switch the bundler, re-estimate\n    if (switcher.canSwitch(null)) {\n      switcher.switch()\n      return estimate4337(\n        account,\n        op,\n        calls,\n        accountStates,\n        network,\n        provider,\n        feeTokens,\n        blockTag,\n        nativeToCheck,\n        switcher,\n        errorCallback\n      )\n    }\n\n    // if there's a bundler error only, it means we cannot do ERC-4337\n    // but we have to do broadcast by EOA\n    feePaymentOptions = []\n    delete bundlerEstimationResult.erc4337GasLimits\n    bundlerEstimationResult.error = null\n  }\n\n  // set the gasUsed to the biggest one found from all estimations\n  const bigIntMax = (...args: bigint[]): bigint => args.reduce((m, e) => (e > m ? e : m))\n  const ambireGas = deployment.gasUsed + accountOpToExecuteBefore.gasUsed + accountOp.gasUsed\n  const estimateGasCall = estimations[2]\n  bundlerEstimationResult.gasUsed = bigIntMax(\n    bundlerEstimationResult.gasUsed,\n    estimateGasCall,\n    ambireGas\n  )\n\n  const isPaymasterUsable = !!bundlerEstimationResult.erc4337GasLimits?.paymaster.isUsable()\n  bundlerEstimationResult.feePaymentOptions = feePaymentOptions\n    .filter((option) => isPaymasterUsable || option.token.address === ZeroAddress)\n    .map((option: FeePaymentOption, index: number) => {\n      // after simulation: add the left over amount as available\n      const localOp = { ...option }\n      if (!option.token.flags.onGasTank) {\n        localOp.availableAmount = feeTokenOutcomes[index][1]\n        localOp.token.amount = feeTokenOutcomes[index][1]\n      }\n\n      localOp.gasUsed = localOp.token.flags.onGasTank ? 5000n : feeTokenOutcomes[index][0]\n      return localOp\n    })\n\n  // this is for EOAs paying for SA in native\n  const nativeToken = feeTokens.find(\n    (token) => token.address === ZeroAddress && !token.flags.onGasTank\n  )\n  const nativeTokenOptions: FeePaymentOption[] = nativeAssetBalances.map(\n    (balance: bigint, key: number) => ({\n      paidBy: nativeToCheck[key],\n      availableAmount: balance,\n      addedNative: l1GasEstimation.fee,\n      token: {\n        ...nativeToken,\n        amount: balance\n      }\n    })\n  )\n  bundlerEstimationResult.feePaymentOptions = [\n    ...bundlerEstimationResult.feePaymentOptions,\n    ...nativeTokenOptions\n  ]\n  return bundlerEstimationResult\n}\n\nexport async function estimate(\n  provider: RPCProvider,\n  network: Network,\n  account: Account,\n  op: AccountOp,\n  accountStates: AccountStates,\n  nativeToCheck: string[],\n  feeTokens: TokenResult[],\n  errorCallback: Function,\n  bundlerSwitcher: BundlerSwitcher,\n  opts?: {\n    calculateRefund?: boolean\n    is4337Broadcast?: boolean\n  },\n  blockFrom: string = '0x0000000000000000000000000000000000000001',\n  blockTag: string | number = 'pending'\n): Promise<EstimateResult> {\n  // if EOA, delegate\n  if (!isSmartAccount(account))\n    return estimateEOA(\n      account,\n      op,\n      accountStates,\n      network,\n      provider,\n      feeTokens,\n      blockFrom,\n      blockTag,\n      errorCallback\n    )\n\n  if (!network.isSAEnabled)\n    return estimationErrorFormatted(\n      new Error('Smart accounts are not available for this network. Please use a Basic Account')\n    )\n  if (!network.areContractsDeployed)\n    return estimationErrorFormatted(\n      new Error(\n        'The Ambire smart contracts are not deployed on this network, yet. You can deploy them via a Basic Account throught the network settings'\n      )\n    )\n\n  // @EntryPoint activation\n  // if the account is v2 without the entry point signer being a signer\n  // and the network is 4337 but doesn't have a paymaster and the account\n  // is deployed for some reason, we should include the activator\n  const calls = [...op.calls.map(toSingletonCall)]\n  const accountState = accountStates[op.accountAddr][op.networkId]\n  if (shouldIncludeActivatorCall(network, account, accountState, false)) {\n    calls.push(getActivatorCall(op.accountAddr))\n  }\n\n  // if 4337, delegate\n  if (opts && opts.is4337Broadcast)\n    return estimate4337(\n      account,\n      op,\n      calls,\n      accountStates,\n      network,\n      provider,\n      feeTokens,\n      blockTag,\n      nativeToCheck,\n      bundlerSwitcher,\n      errorCallback\n    )\n\n  const deploylessEstimator = fromDescriptor(provider, Estimation, !network.rpcNoStateOverride)\n  const optimisticOracle = network.isOptimistic ? OPTIMISTIC_ORACLE : ZeroAddress\n\n  // if the network doesn't have a relayer, we can't pay in fee tokens\n  const filteredFeeTokens = hasRelayerSupport(network) ? feeTokens : []\n\n  // @L2s\n  // craft the probableTxn that's going to be saved on the L1\n  // so we could do proper estimation\n  const encodedCallData = abiCoder.encode(\n    [\n      'bytes', // data\n      'address', // to\n      'address', // from\n      'uint256', // gasPrice\n      'uint256', // type\n      'uint256', // nonce\n      'uint256' // gasLimit\n    ],\n    [\n      getProbableCallData(account, op, accountState, network),\n      op.accountAddr,\n      FEE_COLLECTOR,\n      100000,\n      2,\n      op.nonce,\n      100000\n    ]\n  )\n\n  const args = [\n    account.addr,\n    ...getAccountDeployParams(account),\n    // @TODO can pass 0 here for the addr\n    [\n      account.addr,\n      op.accountOpToExecuteBefore?.nonce || 0,\n      op.accountOpToExecuteBefore?.calls || [],\n      op.accountOpToExecuteBefore?.signature || '0x'\n    ],\n    [account.addr, op.nonce || 1, calls, '0x'],\n    encodedCallData,\n    account.associatedKeys,\n    filteredFeeTokens.map((token) => token.address),\n    FEE_COLLECTOR,\n    nativeToCheck,\n    optimisticOracle\n  ]\n\n  const initializeRequests = () => [\n    deploylessEstimator\n      .call('estimate', args, {\n        from: blockFrom,\n        blockTag\n      })\n      .catch(getHumanReadableEstimationError),\n    estimateGas(account, op, provider, accountState, network).catch(() => 0n)\n  ]\n  const estimations = await estimateWithRetries(\n    initializeRequests,\n    'estimation-deployless',\n    errorCallback\n  )\n\n  if (estimations instanceof Error) return estimationErrorFormatted(estimations)\n\n  const [\n    [\n      deployment,\n      accountOpToExecuteBefore,\n      accountOp,\n      nonce,\n      feeTokenOutcomes,\n      ,\n      nativeAssetBalances,\n      ,\n      l1GasEstimation // [gasUsed, baseFee, totalFee, gasOracle]\n    ]\n  ] = estimations[0]\n\n  let gasUsed = deployment.gasUsed + accountOpToExecuteBefore.gasUsed + accountOp.gasUsed\n\n  // if estimateGas brings a bigger estimation than Estimation.sol, use it\n  const customlyEstimatedGas = estimations[1]\n  if (gasUsed < customlyEstimatedGas) gasUsed = customlyEstimatedGas\n\n  // WARNING: calculateRefund will 100% NOT work in all cases we have\n  // So a warning not to assume this is working\n  if (opts?.calculateRefund) gasUsed = await refund(account, op, provider, gasUsed)\n\n  const feeTokenOptions: FeePaymentOption[] = filteredFeeTokens.map(\n    (token: TokenResult | GasTankTokenResult, key: number) => {\n      // We are using 'availableAmount' here, because it's possible the 'amount' to contains pending top up amount as well\n      const availableAmount =\n        token.flags.onGasTank && 'availableAmount' in token\n          ? token.availableAmount || token.amount\n          : feeTokenOutcomes[key].amount\n      return {\n        paidBy: account.addr,\n        availableAmount,\n        // gasUsed for the gas tank tokens is smaller because of the commitment:\n        // ['gasTank', amount, symbol]\n        // and this commitment costs onchain:\n        // - 1535, if the broadcasting addr is the relayer\n        // - 4035, if the broadcasting addr is different\n        // currently, there are more than 1 relayer addresses and we cannot\n        // be sure which is the one that will broadcast this txn; also, ERC-4337\n        // broadcasts will always consume at least 4035.\n        // setting it to 5000n just be sure\n        gasUsed: token.flags.onGasTank ? 5000n : feeTokenOutcomes[key].gasUsed,\n        addedNative:\n          token.address === ZeroAddress\n            ? l1GasEstimation.feeWithNativePayment\n            : l1GasEstimation.feeWithTransferPayment,\n        token: {\n          ...token,\n          amount: availableAmount\n        }\n      }\n    }\n  )\n\n  // this is for EOAs paying for SA in native\n  const nativeToken = feeTokens.find(\n    (token) => token.address === ZeroAddress && !token.flags.onGasTank\n  )\n  const nativeTokenOptions: FeePaymentOption[] = nativeAssetBalances.map(\n    (balance: bigint, key: number) => ({\n      paidBy: nativeToCheck[key],\n      availableAmount: balance,\n      addedNative: l1GasEstimation.fee,\n      token: {\n        ...nativeToken,\n        amount: balance\n      }\n    })\n  )\n\n  return {\n    gasUsed,\n    // if Estimation.sol estimate is a success, it means the nonce has incremented\n    // so we subtract 1 from it. If it's an error, we return the old one\n    currentAccountNonce: accountOp.success ? Number(nonce - 1n) : Number(nonce),\n    feePaymentOptions: [...feeTokenOptions, ...nativeTokenOptions],\n    error:\n      getInnerCallFailure(\n        accountOp,\n        calls,\n        network,\n        feeTokens.find((token) => token.address === ZeroAddress && !token.flags.onGasTank)?.amount\n      ) || getNonceDiscrepancyFailure(op, nonce)\n  }\n}\n"]}