{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["../../../../src/libs/estimate/interfaces.ts"],"names":[],"mappings":"","sourcesContent":["import { Hex } from '../../interfaces/hex'\nimport { GasSpeeds } from '../../services/bundlers/types'\nimport { AbstractPaymaster } from '../paymaster/abstractPaymaster'\nimport { TokenResult } from '../portfolio'\n\nexport interface BundlerEstimateResult {\n  preVerificationGas: Hex\n  verificationGasLimit: Hex\n  callGasLimit: Hex\n  paymasterVerificationGasLimit: Hex\n  paymasterPostOpGasLimit: Hex\n}\n\nexport interface BundlerStateOverride {\n  [accAddr: string]: {\n    code: string\n    stateDiff?: {\n      [key: string]: string\n    }\n  }\n}\n\nexport interface EstimationFlags {\n  hasNonceDiscrepancy?: boolean\n  has4337NonceDiscrepancy?: boolean\n}\n\nexport interface Erc4337GasLimits {\n  // this is basically gasUsed\n  callGasLimit: string\n  preVerificationGas: string\n  verificationGasLimit: string\n  paymasterVerificationGasLimit: string\n  paymasterPostOpGasLimit: string\n  gasPrice: GasSpeeds\n  paymaster: AbstractPaymaster\n  flags: EstimationFlags\n  feeCallType?: string\n  // put here errors that are not fatal to the signing process\n  // but reactable if known\n  // example: bundler simulation fails because of incorrect 4337 nonce.\n  // The user can still broadcast with EOA but we can also react\n  // to this error by setting the correct nonce and re-estimating\n  nonFatalErrors?: Error[]\n}\n\nexport interface FeePaymentOption {\n  availableAmount: bigint\n  paidBy: string\n  gasUsed: bigint\n  addedNative: bigint\n  token: TokenResult\n}\n\nexport interface EstimateResult {\n  gasUsed: bigint\n  // the nonce should always be the current value of account.nonce()\n  // even in ERC-4337 case, we might use the account.nonce() for\n  // signatures. We don't need the EntryPoint nonce\n  currentAccountNonce: number\n  feePaymentOptions: FeePaymentOption[]\n  erc4337GasLimits?: Erc4337GasLimits\n  error: Error | null\n  // put here errors that are not fatal to the signing process\n  // but reactable if known\n  // example: bundler simulation fails because of incorrect 4337 nonce.\n  // The user can still broadcast with EOA but we can also react\n  // to this error by setting the correct nonce and re-estimating\n  nonFatalErrors?: Error[]\n}\n\nexport interface ProviderEstimation {\n  gasUsed: bigint\n  feePaymentOptions: FeePaymentOption[]\n}\n\nexport interface AmbireEstimation {\n  gasUsed: bigint\n  deploymentGas: bigint\n  feePaymentOptions: FeePaymentOption[]\n  ambireAccountNonce: number\n  flags: EstimationFlags\n}\n\nexport interface PerCallEstimation {\n  gasUsed: bigint\n  gasUsedPerCall: bigint[]\n}\n\n// Null means that the estimation was not done (e.g. it's irrelevant to the account type)\nexport interface FullEstimation {\n  provider: ProviderEstimation | Error | null\n  ambire: AmbireEstimation | Error // Ambire estimation is used always\n  bundler: Erc4337GasLimits | Error | null\n  // flags that signal to the app what needs to be handled if a state\n  // inconsistency issue was found during estimation\n  flags: EstimationFlags\n}\n\nexport interface FullEstimationSummary {\n  providerEstimation?: ProviderEstimation\n  ambireEstimation?: AmbireEstimation\n  bundlerEstimation?: Erc4337GasLimits\n  flags: EstimationFlags\n}\n"]}