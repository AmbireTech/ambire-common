{"version":3,"file":"parseEmail.js","sourceRoot":"","sources":["../../../../src/libs/dkim/parseEmail.ts"],"names":[],"mappings":"AAAA;;;EAGE;AACF,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAA;AAC/B,OAAO,YAAY,MAAM,gBAAgB,CAAA;AACzC,OAAO,qBAAqB,MAAM,yBAAyB,CAAA;AAC3D,OAAO,UAAU,MAAM,cAAc,CAAA;AACrC,OAAO,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAA;AAEnC,MAAM,CAAC,OAAO,CAAC,KAAK,UAAU,UAAU,CAAC,KAAU;IAEjD,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE;QACjD,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS;aAC7B,KAAK,CAAC,GAAG,CAAC;aACV,GAAG,EAAE;aACL,WAAW,EAAE,CAAA;QAEhB,MAAM,QAAQ,GAAG,UAAU,CAAC,SAAS,CAAC;aACnC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC;aAC1B,MAAM,EAAE,CAAA;QAEX,MAAM,eAAe,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QAEnE,IAAI,eAAe,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAA;SAC5C;QAED,MAAM,IAAI,GAAG,UAAU,CAAC,SAAS,CAAC;aAC/B,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;aAC5B,MAAM,EAAE,CAAA;QAEX,OAAO;YACL,GAAG,IAAI;YACP,IAAI;SACL,CAAA;IACH,CAAC,CAAC,CAAA;IAEF,kBAAkB;IAClB,MAAM,iBAAiB,GAAQ,MAAM,OAAO,CAAC,GAAG,CAC9C,KAAK,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE,CACtB,YAAY,CAAC;QACX,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM;QAC7B,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ;KAClC,CAAC,CACH,CACF,CAAA;IAED,MAAM,UAAU,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC,KAAU,EAAE,EAAE;QACtD,MAAM,EAAE,SAAS,EAAE,GAAG,KAAK,CAAA;QAC3B,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,qBAAqB,CAAC,SAAS,CAAC,CAAA;QAE9D,OAAO;YACL,GAAG,KAAK;YACR,QAAQ;YACR,OAAO;SACR,CAAA;IACH,CAAC,CAAC,CAAA;IAEF,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,CAAM,EAAE,EAAE;QACrC,MAAM,QAAQ,GAAG,UAAU,CAAC;YAC1B,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS;YACnC,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ;YAChC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO;SAC/B,CAAC,CAAA;QAEF,OAAO;YACL,GAAG,IAAI;YACP,GAAG,UAAU,CAAC,CAAC,CAAC;YAChB,QAAQ;SACT,CAAA;IACH,CAAC,CAAC,CAAA;AACJ,CAAC","sourcesContent":["/*\n  parse and return email data\n  (nodejs)\n*/\nimport { parse } from './parse'\nimport getPublicKey from './getPublicKey'\nimport publicKeyToComponents from './publicKeyToComponents'\nimport toSolidity from './toSolidity'\nimport { createHash } from 'crypto'\n\nexport default async function parseEmail(email: any) {\n\n  const dkims = parse(email).dkims.map((dkim: any) => {\n    const algorithm = dkim.algorithm\n      .split('-')\n      .pop()\n      .toUpperCase()\n\n    const bodyHash = createHash(algorithm)\n      .update(dkim.processedBody)\n      .digest()\n\n    const bodyHashMatched = bodyHash.compare(dkim.signature.hash) !== 0\n\n    if (bodyHashMatched) {\n      throw new Error('body hash did not verify')\n    }\n\n    const hash = createHash(algorithm)\n      .update(dkim.processedHeader)\n      .digest()\n\n    return {\n      ...dkim,\n      hash\n    }\n  })\n\n  // get dns records\n  const publicKeysEntries: any = await Promise.all(\n    dkims.map((dkim: any) =>\n      getPublicKey({\n        domain: dkim.signature.domain,\n        selector: dkim.signature.selector\n      })\n    )\n  )\n\n  const publicKeys = publicKeysEntries.map((entry: any) => {\n    const { publicKey } = entry\n    const { exponent, modulus } = publicKeyToComponents(publicKey)\n\n    return {\n      ...entry,\n      exponent,\n      modulus\n    }\n  })\n\n  return dkims.map((dkim: any, i: any) => {\n    const solidity = toSolidity({\n      algorithm: dkim.algorithm,\n      hash: dkim.hash,\n      signature: dkim.signature.signature,\n      exponent: publicKeys[i].exponent,\n      modulus: publicKeys[i].modulus\n    })\n\n    return {\n      ...dkim,\n      ...publicKeys[i],\n      solidity\n    }\n  })\n}\n"]}