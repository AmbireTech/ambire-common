{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../../src/libs/errorHumanizer/helpers.ts"],"names":[],"mappings":";;;AAAA,qDAAsE;AACtE,iDAA+D;AAG/D,SAAS,yBAAyB,CAChC,SAAoB,EACpB,MAA8B,EAC9B,aAAqB,EACrB,iBAAyB;IAEzB,MAAM,YAAY,GAAG,IAAA,sCAA4B,EAAC,MAAM,IAAI,EAAE,CAAC,CAAA;IAC/D,MAAM,sBAAsB,GAAG,GAAG,YAAY,IAAI,CAAA;IAClD,MAAM,aAAa,GAAG,GAAG,sBAAsB,4DAA4D,CAAA;IAC3G,MAAM,MAAM,GAAG,SAAS,EAAE,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;IAEnD,QAAQ,SAAS,EAAE;QACjB,KAAK,iBAAS,CAAC,YAAY,CAAC;QAC5B,KAAK,iBAAS,CAAC,QAAQ;YACrB,OAAO,GAAG,aAAa,iCAAiC,MAAM,UAAU,aAAa,EAAE,CAAA;QACzF,KAAK,iBAAS,CAAC,cAAc;YAC3B,OAAO,GAAG,aAAa,yBAAyB,aAAa,EAAE,CAAA;QACjE,KAAK,iBAAS,CAAC,YAAY;YACzB,OAAO,GAAG,aAAa,iBAAiB,sBAAsB,EAAE,CAAA;QAClE,KAAK,iBAAS,CAAC,SAAS,CAAC;QACzB,KAAK,iBAAS,CAAC,YAAY;YACzB,OAAO,GAAG,aAAa,wBAAwB,aAAa,EAAE,CAAA;QAChE,KAAK,iBAAS,CAAC,qBAAqB;YAClC,OAAO,YAAY;gBACjB,CAAC,CAAC,GAAG,aAAa,2BAA2B,sBAAsB,EAAE;gBACrE,CAAC,CAAC,GAAG,aAAa,+CAA+C,aAAa,EAAE,CAAA;QACpF,0DAA0D;QAC1D,KAAK,iBAAS,CAAC,kBAAkB;YAC/B,OAAO,uBAAuB,CAAA;QAChC,mEAAmE;QACnE,KAAK,iBAAS,CAAC,WAAW,CAAC;QAC3B,KAAK,iBAAS,CAAC,UAAU,CAAC;QAC1B,KAAK,iBAAS,CAAC,WAAW;YACxB,OAAO,GAAG,aAAa,wBAAwB,aAAa,EAAE,CAAA;QAChE;YACE,OAAO,iBAAiB,CAAA;KAC3B;AACH,CAAC;AA4BQ,8DAAyB;AA1BlC,MAAM,4BAA4B,GAAG,CACnC,WAA0B,EAC1B,MAA6B,EAC7B,aAAqB,EACrB,MAA8B,EAC9B,CAAM,EACN,EAAE;IACF,IAAI,WAAW;QAAE,OAAO,WAAW,CAAA;IAEnC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,EAAE,KAAK,EAAE,OAAO,IAAI,CAAC,EAAE,OAAO,CAAA;IAC9D,IAAI,OAAO,GAAG,IAAI,CAAA;IAElB,IAAI,YAAY,EAAE;QAChB,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YACvB,MAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE,CACpD,YAAY,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,WAAW,EAAE,CAAC,CAC/D,CAAA;YACD,IAAI,CAAC,UAAU;gBAAE,OAAM;YAEvB,OAAO,GAAG,GAAG,aAAa,IAAI,KAAK,CAAC,OAAO,EAAE,CAAA;QAC/C,CAAC,CAAC,CAAA;KACH;IAED,OAAO,OAAO,CAAA;AAChB,CAAC,CAAA;AAEmC,oEAA4B","sourcesContent":["import { getErrorCodeStringFromReason } from '../errorDecoder/helpers'\nimport { DecodedError, ErrorType } from '../errorDecoder/types'\nimport { ErrorHumanizerError } from './types'\n\nfunction getGenericMessageFromType(\n  errorType: ErrorType,\n  reason: DecodedError['reason'],\n  messagePrefix: string,\n  lastResortMessage: string\n): string {\n  const reasonString = getErrorCodeStringFromReason(reason ?? '')\n  const messageSuffixNoSupport = `${reasonString}\\n`\n  const messageSuffix = `${messageSuffixNoSupport}Please try again or contact Ambire support for assistance.`\n  const origin = errorType?.split('Error')?.[0] || ''\n\n  switch (errorType) {\n    case ErrorType.RelayerError:\n    case ErrorType.RpcError:\n      return `${messagePrefix} of an unknown error (Origin: ${origin} call).${messageSuffix}`\n    case ErrorType.PaymasterError:\n      return `${messagePrefix} of a Paymaster Error.${messageSuffix}`\n    case ErrorType.BundlerError:\n      return `${messagePrefix} it's invalid.${messageSuffixNoSupport}`\n    case ErrorType.CodeError:\n    case ErrorType.UnknownError:\n      return `${messagePrefix} of an unknown error.${messageSuffix}`\n    case ErrorType.InnerCallFailureError:\n      return reasonString\n        ? `${messagePrefix} it will revert onchain.${messageSuffixNoSupport}`\n        : `${messagePrefix} it will revert onchain with reason unknown.${messageSuffix}`\n    // I don't think we should say anything else for this case\n    case ErrorType.UserRejectionError:\n      return 'Transaction rejected.'\n    // Panic error may scare the user so let's call it a contract error\n    case ErrorType.CustomError:\n    case ErrorType.PanicError:\n    case ErrorType.RevertError:\n      return `${messagePrefix} of a contract error.${messageSuffix}`\n    default:\n      return lastResortMessage\n  }\n}\n\nconst getHumanReadableErrorMessage = (\n  commonError: string | null,\n  errors: ErrorHumanizerError[],\n  messagePrefix: string,\n  reason: DecodedError['reason'],\n  e: any\n) => {\n  if (commonError) return commonError\n\n  const checkAgainst = reason || e?.error?.message || e?.message\n  let message = null\n\n  if (checkAgainst) {\n    errors.forEach((error) => {\n      const isMatching = error.reasons.some((errorReason) =>\n        checkAgainst.toLowerCase().includes(errorReason.toLowerCase())\n      )\n      if (!isMatching) return\n\n      message = `${messagePrefix} ${error.message}`\n    })\n  }\n\n  return message\n}\n\nexport { getGenericMessageFromType, getHumanReadableErrorMessage }\n"]}