{"version":3,"file":"gecko.js","sourceRoot":"","sources":["../../../../src/libs/portfolio/gecko.ts"],"names":[],"mappings":";;;;AAAA,4DAA2B;AAE3B,sDAAsD;AAGtD,6CAAuC;AAEvC,gBAAM,CAAC,MAAM,EAAE,CAAA;AAEf,yEAAyE;AACzE,MAAM,WAAW,GAAG,EAAE,CAAA;AAEtB,SAAgB,uBAAuB,CAAC,SAAiB,EAAE,OAAgB;IACzE,OAAO,IAAA,yBAAa,EAAC,SAAS,EAAE,OAAO,CAAC,IAAI,SAAS,CAAC,WAAW,EAAE,CAAA;AACrE,CAAC;AAFD,0DAEC;AAED,SAAgB,mBAAmB,CAAC,KAAqB;IACvD,MAAM,QAAQ,GAA6B,EAAE,CAAA;IAE7C,gDAAgD;IAChD,KAAK,MAAM,SAAS,IAAI,KAAK,EAAE;QAC7B,MAAM,OAAO,GAAG,IAAA,yBAAa,EAAC,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;QAC7E,sGAAsG;QACtG,iCAAiC;QACjC,0FAA0F;QAC1F,uCAAuC;QACvC,IAAI,CAAC,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU;YAAE,SAAQ;QAE5D,IAAI,SAAS,GAAW,SAAS,CAAC,IAAI,CAAC,YAAY,CAAA;QAEnD,IAAI,OAAO;YAAE,SAAS,IAAI,UAAU,CAAA;;YAC/B,SAAS,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,CAAA;QAEjD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;YAAE,QAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,CAAA;QAClD,QAAQ,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;KACpC;IACD,mGAAmG;IACnG,uGAAuG;IACvG,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;SACnC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE,EAAE,CAC3B,IAAA,qBAAQ,EAAC,YAAY,EAAE,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC,CACjF;SACA,IAAI,CAAC,CAAC,CAAC,CAAA;IACV,MAAM,KAAK,GAAG,CAAC,CAAQ,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAA;IAClE,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,YAAY,EAAE,EAAE,EAAE;QACzC,qDAAqD;QACrD,MAAM,YAAY,GAAG,YAAY,CAAC,CAAC,CAAE,CAAC,IAAI,CAAC,YAAY,CAAA;QACvD,MAAM,aAAa,GAAG,YAAY,CAAC,CAAC,CAAE,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAA;QAE9D,MAAM,UAAU,GAAG,yBAAyB,CAAA;QAE5C,IAAI,GAAG,CAAA;QACP,IAAI,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC;YACzB,GAAG,GAAG,GAAG,UAAU,4BAA4B,KAAK,CAClD,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAA,yBAAa,EAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CACvE,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,YAAY,EAAE,CAAA;;YAE7C,GAAG,GAAG,GAAG,UAAU,8BAA8B,aAAa,uBAAuB,KAAK,CACxF,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CACxC,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,YAAY,EAAE,CAAA;QAC/C,OAAO,EAAE,GAAG,EAAE,YAAY,EAAE,CAAA;IAC9B,CAAC,CAAC,CAAA;AACJ,CAAC;AA9CD,kDA8CC","sourcesContent":["import dotenv from 'dotenv'\n\nimport { geckoIdMapper } from '../../consts/coingecko'\nimport { Network } from '../../interfaces/network'\nimport { QueueElement, Request } from './batcher'\nimport { paginate } from './pagination'\n\ndotenv.config()\n\n// max tokens per request; we seem to have faster results when it's lower\nconst BATCH_LIMIT = 40\n\nexport function geckoResponseIdentifier(tokenAddr: string, network: Network): string {\n  return geckoIdMapper(tokenAddr, network) || tokenAddr.toLowerCase()\n}\n\nexport function geckoRequestBatcher(queue: QueueElement[]): Request[] {\n  const segments: { [key: string]: any[] } = {}\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const queueItem of queue) {\n    const geckoId = geckoIdMapper(queueItem.data.address, queueItem.data.network)\n    // If we can't determine the Gecko platform ID, we shouldn't make a request to price (cena.ambire.com)\n    // since it would return nothing.\n    // This can happen when adding a custom network that doesn't have a CoinGecko platform ID.\n    // eslint-disable-next-line no-continue\n    if (!geckoId && !queueItem.data.network.platformId) continue\n\n    let segmentId: string = queueItem.data.baseCurrency\n\n    if (geckoId) segmentId += ':natives'\n    else segmentId += `:${queueItem.data.network.id}`\n\n    if (!segments[segmentId]) segments[segmentId] = []\n    segments[segmentId].push(queueItem)\n  }\n  // deduplicating is OK because we use a key-based mapping (responseIdentifier) to map the responses\n  // @TODO deduplication should happen BEFORE the pagination but without dropping items from queueSegment\n  const pages = Object.entries(segments)\n    .map(([key, queueSegment]) =>\n      paginate(queueSegment, BATCH_LIMIT).map((page) => ({ key, queueSegment: page }))\n    )\n    .flat(1)\n  const dedup = (x: any[]) => x.filter((y, i) => x.indexOf(y) === i)\n  return pages.map(({ key, queueSegment }) => {\n    // This is OK because we're segmented by baseCurrency\n    const baseCurrency = queueSegment[0]!.data.baseCurrency\n    const geckoPlatform = queueSegment[0]!.data.network.platformId\n\n    const mainApiUrl = 'https://cena.ambire.com'\n\n    let url\n    if (key.endsWith('natives'))\n      url = `${mainApiUrl}/api/v3/simple/price?ids=${dedup(\n        queueSegment.map((x) => geckoIdMapper(x.data.address, x.data.network))\n      ).join('%2C')}&vs_currencies=${baseCurrency}`\n    else\n      url = `${mainApiUrl}/api/v3/simple/token_price/${geckoPlatform}?contract_addresses=${dedup(\n        queueSegment.map((x) => x.data.address)\n      ).join('%2C')}&vs_currencies=${baseCurrency}`\n    return { url, queueSegment }\n  })\n}\n"]}