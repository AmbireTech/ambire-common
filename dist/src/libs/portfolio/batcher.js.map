{"version":3,"file":"batcher.js","sourceRoot":"","sources":["../../../../src/libs/portfolio/batcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { Fetch } from '../../interfaces/fetch'\n\nexport interface QueueElement {\n  resolve: Function\n  reject: Function\n  fetch: Fetch\n  data: any\n}\n\nexport interface Request {\n  url: string\n  queueSegment: QueueElement[]\n}\n\nexport type RequestGenerator = (queue: QueueElement[]) => Request[]\n\nexport default function batcher(\n  fetch: Fetch,\n  requestGenerator: RequestGenerator,\n  timeoutSettings?: {\n    timeoutAfter: number\n    timeoutErrorMessage: string\n  },\n  batchDebounce: number = 0\n): Function {\n  let queue: QueueElement[] = []\n\n  async function resolveQueue() {\n    // Note: intentionally just using the first values in the queue\n    if (queue.length === 0) return\n    const queueCopy = queue\n    queue = []\n    await Promise.all(\n      // we let the requestGenerator split the queue into parts, each of it will be resolved with it's own url\n      // this allows the possibility of one queue being resolved with multiple requests, for example if the API needs to be called\n      // separately for each network\n      // useful also if the API is limited to a certain # and we want to paginate\n      requestGenerator(queueCopy).map(async ({ url, queueSegment }) => {\n        try {\n          const fetchPromise = fetch(url).then(async (resp) => {\n            const body = await resp.json()\n            if (resp.status !== 200) throw body\n            if (body.hasOwnProperty('message')) throw body\n            if (body.hasOwnProperty('error')) throw body\n            if (Array.isArray(body)) {\n              if (body.length !== queueSegment.length)\n                throw new Error('internal error: queue length and response length mismatch')\n              queueSegment.forEach(({ resolve }, i) => resolve(body[i]))\n            } else if (queueSegment.every((x) => typeof x.data.responseIdentifier === 'string')) {\n              queueSegment.forEach(({ resolve, data }) =>\n                resolve(body[data.responseIdentifier as string])\n              )\n            } else throw body\n          })\n\n          if (timeoutSettings) {\n            const timeoutPromise = new Promise((_, reject) => {\n              setTimeout(() => {\n                reject(new Error('Request timed out'))\n              }, timeoutSettings.timeoutAfter)\n            })\n            await Promise.race([fetchPromise, timeoutPromise])\n          } else {\n            await fetchPromise\n          }\n        } catch (e: any) {\n          if (e.message === 'Request timed out' && timeoutSettings) {\n            console.error(timeoutSettings.timeoutErrorMessage)\n          }\n          queueSegment.forEach(({ reject }) => reject(e))\n        }\n      })\n    )\n  }\n  return async (data: any): Promise<any> => {\n    // always do the setTimeout - if it's a second or third batchedCall within a tick, all setTimeouts will fire but only the first will perform work\n    setTimeout(resolveQueue, batchDebounce)\n    return new Promise((resolve, reject) => {\n      queue.push({ resolve, reject, fetch, data })\n    })\n  }\n}\n"]}