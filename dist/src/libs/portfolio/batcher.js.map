{"version":3,"file":"batcher.js","sourceRoot":"","sources":["../../../../src/libs/portfolio/batcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { Fetch } from '../../interfaces/fetch'\nimport { fetchWithTimeout } from '../../utils/fetch'\n\nexport interface QueueElement {\n  resolve: Function\n  reject: Function\n  fetch: Fetch\n  data: {\n    [key: string]: any\n  }\n  // Keep track of duplicates that should be resolved together\n  linkedDuplicates?: QueueElement[]\n}\n\nexport interface Request {\n  url: string\n  queueSegment: QueueElement[]\n}\n\nexport type RequestGenerator = (queue: QueueElement[]) => Request[]\n\nexport default function batcher(\n  fetch: Fetch,\n  requestGenerator: RequestGenerator,\n  options: {\n    timeoutSettings?: {\n      timeoutAfter: number\n      timeoutErrorMessage: string\n    }\n    batchDebounce?: number\n    dedupeByKeys?: string[]\n  }\n): Function {\n  const { timeoutSettings, batchDebounce = 0, dedupeByKeys = [] } = options\n  let queue: QueueElement[] = []\n  let timeoutId: NodeJS.Timeout | null = null\n\n  // Helper function to deduplicate queue elements\n  function deduplicateQueue(inputQueue: QueueElement[]): QueueElement[] {\n    if (!dedupeByKeys.length) return inputQueue\n\n    const uniqueElements: QueueElement[] = []\n    const seen = new Map<string, QueueElement>()\n\n    inputQueue.forEach((element) => {\n      // Create a key based on specified fields to identify duplicates\n      const keyParts = dedupeByKeys.map((key) => {\n        const value = element.data[key]\n        return typeof value === 'object' ? JSON.stringify(value) : String(value)\n      })\n\n      const uniqueKey = keyParts.join(':')\n\n      if (seen.has(uniqueKey)) {\n        // Link the duplicate to the original request\n        const original = seen.get(uniqueKey)\n        if (!original) return\n\n        if (!original.linkedDuplicates) {\n          original.linkedDuplicates = []\n        }\n        original.linkedDuplicates.push(element)\n      } else {\n        // New unique element\n        seen.set(uniqueKey, element)\n        uniqueElements.push(element)\n      }\n    })\n\n    return uniqueElements\n  }\n\n  async function resolveQueue() {\n    // Note: intentionally just using the first values in the queue\n    if (queue.length === 0) return\n\n    // Process duplicates before generating requests\n    const deduplicatedQueue = deduplicateQueue(queue)\n\n    const queueCopy = deduplicatedQueue\n    queue = []\n\n    await Promise.all(\n      // we let the requestGenerator split the queue into parts, each of it will be resolved with it's own url\n      // this allows the possibility of one queue being resolved with multiple requests, for example if the API needs to be called\n      // separately for each network\n      // useful also if the API is limited to a certain # and we want to paginate\n      requestGenerator(queueCopy).map(async ({ url, queueSegment }) => {\n        try {\n          const fetchPromise = fetchWithTimeout(\n            fetch,\n            url,\n            {},\n            timeoutSettings?.timeoutAfter || 20000\n          ).then(async (resp) => {\n            const body = await resp.json()\n            if (resp.status !== 200) throw body\n            if (Object.prototype.hasOwnProperty.call(body, 'message')) throw body\n            if (Object.prototype.hasOwnProperty.call(body, 'error')) throw body\n            if (Array.isArray(body)) {\n              if (body.length !== queueSegment.length)\n                throw new Error('internal error: queue length and response length mismatch')\n              queueSegment.forEach(({ resolve, linkedDuplicates }, i) => {\n                resolve(body[i])\n                // Resolve linked duplicates with the same result\n                linkedDuplicates?.forEach((duplicate) => duplicate.resolve(body[i]))\n              })\n            } else if (queueSegment.every((x) => typeof x.data.responseIdentifier === 'string')) {\n              queueSegment.forEach(({ resolve, data, linkedDuplicates }) => {\n                const result = body[data.responseIdentifier as string]\n                resolve(result)\n                // Resolve linked duplicates with the same result\n                linkedDuplicates?.forEach((duplicate) => duplicate.resolve(result))\n              })\n            } else throw body\n          })\n\n          await fetchPromise\n        } catch (e: any) {\n          if (e.message === 'request-timeout' && timeoutSettings) {\n            console.error('Batcher error: ', timeoutSettings.timeoutErrorMessage)\n          } else {\n            console.log('Batcher error:', e)\n          }\n          queueSegment.forEach(({ reject, linkedDuplicates }) => {\n            reject(e)\n            // Reject linked duplicates with the same error\n            linkedDuplicates?.forEach((duplicate) => duplicate.reject(e))\n          })\n        }\n      })\n    )\n  }\n\n  return async (data: any): Promise<any> => {\n    // always do the setTimeout - if it's a second or third batchedCall within a tick, all setTimeouts will fire but only the first will perform work\n    // Clear the existing timeout to avoid multiple resolveQueue calls\n    if (timeoutId) {\n      clearTimeout(timeoutId)\n    }\n\n    // Set a new timeout for the resolveQueue call\n    timeoutId = setTimeout(resolveQueue, batchDebounce)\n\n    return new Promise((resolve, reject) => {\n      queue.push({ resolve, reject, fetch, data })\n    })\n  }\n}\n"]}