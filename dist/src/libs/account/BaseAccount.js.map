{"version":3,"file":"BaseAccount.js","sourceRoot":"","sources":["../../../../src/libs/account/BaseAccount.ts"],"names":[],"mappings":";;;AAeA,MAAsB,WAAW;IACrB,OAAO,CAAS;IAEhB,OAAO,CAAS;IAEhB,YAAY,CAAqB;IAE3C,YAAY,OAAgB,EAAE,OAAgB,EAAE,YAAiC;QAC/E,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAA;IAClC,CAAC;IAED,UAAU;QACR,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;IAqDD,oEAAoE;IACpE,0BAA0B,CAAC,eAAuB;QAChD,OAAO,KAAK,CAAA;IACd,CAAC;IAED,wCAAwC;IACxC,uBAAuB,CAAC,eAAuB;QAC7C,OAAO,KAAK,CAAA;IACd,CAAC;IAED,iDAAiD;IACjD,8BAA8B,CAAC,EAAa;QAC1C,OAAO,KAAK,CAAA;IACd,CAAC;IAED,sEAAsE;IACtE,uBAAuB,CAAC,MAAqB;QAC3C,OAAO,SAAS,CAAA;IAClB,CAAC;IAED,mCAAmC;IACnC,oBAAoB,CAAC,eAAuB;QAC1C,OAAO,KAAK,CAAA;IACd,CAAC;IAED,aAAa;QACX,OAAO,KAAK,CAAA;IACd,CAAC;CACF;AAhGD,kCAgGC","sourcesContent":["/* eslint-disable class-methods-use-this */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Account, AccountOnchainState } from '../../interfaces/account'\nimport { Hex } from '../../interfaces/hex'\nimport { Network } from '../../interfaces/network'\nimport { AccountOp } from '../accountOp/accountOp'\nimport {\n  BundlerStateOverride,\n  FeePaymentOption,\n  FullEstimation,\n  FullEstimationSummary\n} from '../estimate/interfaces'\nimport { TokenResult } from '../portfolio'\nimport { UserOperation } from '../userOperation/types'\n\nexport abstract class BaseAccount {\n  protected account: Account\n\n  protected network: Network\n\n  protected accountState: AccountOnchainState\n\n  constructor(account: Account, network: Network, accountState: AccountOnchainState) {\n    this.account = account\n    this.network = network\n    this.accountState = accountState\n  }\n\n  getAccount() {\n    return this.account\n  }\n\n  // each implementation should declare when an estimation failure is critical\n  // and we should display it to the user\n  abstract getEstimationCriticalError(estimation: FullEstimation, op: AccountOp): Error | null\n\n  abstract supportsBundlerEstimation(): boolean\n\n  abstract getAvailableFeeOptions(\n    estimation: FullEstimationSummary,\n    feePaymentOptions: FeePaymentOption[],\n    op: AccountOp\n  ): FeePaymentOption[]\n\n  abstract getGasUsed(\n    estimation: FullEstimationSummary | Error,\n    // all of the options below need to be passed. Each implementation\n    // decides on its own which are actually important for it\n    options: {\n      feeToken: TokenResult\n      op: AccountOp\n    }\n  ): bigint\n\n  abstract getBroadcastOption(\n    feeOption: FeePaymentOption,\n    options: {\n      op: AccountOp\n      isSponsored?: boolean\n    }\n  ): string\n\n  // can the account type use the receiving amount after the estimation\n  // to pay the fee. Smart accounts can but EOA / 7702 EOAs cannot\n  // as paying in native means broadcasting as an EOA - you have to\n  // have the native before broadcast\n  abstract canUseReceivingNativeForFee(amount: bigint): boolean\n\n  // when using the ambire estimation, the broadcast gas is not included\n  // so smart accounts that broadacast with EOAs/relayer do not have the\n  // additional broadcast gas included\n  //\n  // Additionally, 7702 EOAs that use the ambire estimation suffer from\n  // the same problem as they do broadcast by themselves by only\n  // the smart account contract gas is calculated\n  //\n  // we return the calldata specific for each account to allow\n  // the estimation to calculate it correctly\n  abstract getBroadcastCalldata(accountOp: AccountOp): Hex\n\n  // each account should declare if it supports atomicity\n  abstract getAtomicStatus(): 'unsupported' | 'supported' | 'ready'\n\n  // this is specific for v2 accounts, hardcoding a false for all else\n  shouldIncludeActivatorCall(broadcastOption: string) {\n    return false\n  }\n\n  // this is specific for eoa7702 accounts\n  shouldSignAuthorization(broadcastOption: string): boolean {\n    return false\n  }\n\n  // valid only EOAs in very specific circumstances\n  shouldBroadcastCallsSeparately(op: AccountOp): boolean {\n    return false\n  }\n\n  // describe the state override needed during bundler estimation if any\n  getBundlerStateOverride(userOp: UserOperation): BundlerStateOverride | undefined {\n    return undefined\n  }\n\n  // this is specific for v2 accounts\n  shouldSignDeployAuth(broadcastOption: string): boolean {\n    return false\n  }\n\n  isSponsorable(): boolean {\n    return false\n  }\n}\n"]}