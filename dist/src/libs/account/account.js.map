{"version":3,"file":"account.js","sourceRoot":"","sources":["../../../../src/libs/account/account.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbiCoder, getAddress, hexlify, Interface, toBeHex, toUtf8Bytes, ZeroAddress } from 'ethers'\n\nimport { DEFAULT_ACCOUNT_LABEL } from '../../consts/account'\nimport { AMBIRE_ACCOUNT_FACTORY } from '../../consts/deploy'\nimport { SMART_ACCOUNT_SIGNER_KEY_DERIVATION_OFFSET } from '../../consts/derivation'\nimport { SPOOF_SIGTYPE } from '../../consts/signatures'\nimport {\n  Account,\n  AccountId,\n  AccountOnPage,\n  AccountPreferences,\n  ImportStatus\n} from '../../interfaces/account'\nimport { KeyIterator } from '../../interfaces/keyIterator'\nimport { Key } from '../../interfaces/keystore'\nimport { DKIM_VALIDATOR_ADDR, getSignerKey, RECOVERY_DEFAULTS } from '../dkim/recovery'\nimport { getBytecode } from '../proxyDeploy/bytecode'\nimport { PrivLevels } from '../proxyDeploy/deploy'\nimport { getAmbireAccountAddress } from '../proxyDeploy/getAmbireAddressTwo'\n\n/**\n * The minimum requirements are emailFrom and secondaryKey.\n * - emailFrom is the email from the email vault\n * - secondaryKey is the recoveryKey set in the email vault\n * - acceptUnknownSelectors: sets whether recovery can be done by DNSSEC keys\n * - waitUntilAcceptAdded: how much time to wait before the user accepts\n * a DNSSEC key\n * - waitUntilAcceptRemoved: how much time to wait before the user accepts\n * a removal of a DNSSEC key\n * - acceptEmptyDKIMSig: can recovery be performed without DKIM\n * - acceptEmptySecondSig: can recovery be performed without secondaryKey\n * - onlyOneSigTimelock: in case of 1/2 multisig, how much time to wait\n * before the recovery transaction can be executed\n */\ninterface DKIMRecoveryAccInfo {\n  emailFrom: string\n  secondaryKey: string\n  waitUntilAcceptAdded?: BigInt\n  waitUntilAcceptRemoved?: BigInt\n  acceptEmptyDKIMSig?: boolean\n  acceptEmptySecondSig?: boolean\n  onlyOneSigTimelock?: BigInt\n}\n\n// returns to, data\nexport function getAccountDeployParams(account: Account): [string, string] {\n  // for EOAs, we do not throw an error anymore as we need fake\n  // values for the simulation\n  if (account.creation === null) return [ZeroAddress, '0x']\n\n  const factory = new Interface(['function deploy(bytes calldata code, uint256 salt) external'])\n  return [\n    account.creation.factoryAddr,\n    factory.encodeFunctionData('deploy', [account.creation.bytecode, account.creation.salt])\n  ]\n}\n\nexport function getBasicAccount(addr: string, existingAccounts: Account[]): Account {\n  const { preferences } = existingAccounts.find((acc) => acc.addr === addr) || {}\n  return {\n    addr,\n    associatedKeys: [addr],\n    initialPrivileges: [],\n    creation: null,\n    preferences: {\n      label: preferences?.label || DEFAULT_ACCOUNT_LABEL,\n      pfp: preferences?.pfp || addr\n    }\n  }\n}\n\nexport async function getSmartAccount(\n  privileges: PrivLevels[],\n  existingAccounts: Account[]\n): Promise<Account> {\n  const bytecode = await getBytecode(privileges)\n  const addr = getAmbireAccountAddress(AMBIRE_ACCOUNT_FACTORY, bytecode)\n  const { preferences } = existingAccounts.find((acc) => acc.addr === addr) || {}\n\n  return {\n    addr,\n    initialPrivileges: privileges.map((priv) => [priv.addr, priv.hash]),\n    associatedKeys: privileges.map((priv) => priv.addr),\n    creation: {\n      factoryAddr: AMBIRE_ACCOUNT_FACTORY,\n      bytecode,\n      salt: toBeHex(0, 32)\n    },\n    preferences: {\n      label: preferences?.label || DEFAULT_ACCOUNT_LABEL,\n      pfp: preferences?.pfp || addr\n    }\n  }\n}\n\nexport function getSpoof(account: Account) {\n  const abiCoder = new AbiCoder()\n  return abiCoder.encode(['address'], [account.associatedKeys[0]]) + SPOOF_SIGTYPE\n}\n\n/**\n * Create a DKIM recoverable email smart account\n *\n * @param recoveryInfo DKIMRecoveryAccInfo\n * @param associatedKey the key that has privileges\n * @returns Promise<Account>\n */\nexport async function getEmailAccount(\n  recoveryInfo: DKIMRecoveryAccInfo,\n  associatedKey: string\n): Promise<Account> {\n  // const domain: string = recoveryInfo.emailFrom.split('@')[1]\n\n  // TODO: make getEmailAccount work with cloudflare\n\n  // try to take the dkimKey from the list of knownSelectors\n  // if we cannot, we query a list of frequentlyUsedSelectors to try\n  // to find the dkim key\n  // let selector = knownSelectors[domain as keyof typeof knownSelectors] ?? ''\n  // let dkimKey = selector ? await getPublicKeyIfAny({domain, selector: selector}) : ''\n  // if (!dkimKey) {\n  //   const promises = frequentlyUsedSelectors.map(sel => getPublicKeyIfAny({domain, selector: sel}))\n  //   const results = await Promise.all(promises)\n  //   for (let i = 0; i < results.length; i++) {\n  //     if (results[i]) {\n  //       dkimKey = results[i]\n  //       selector = frequentlyUsedSelectors[i]\n  //       break\n  //     }\n  //   }\n  // }\n\n  // if there's no dkimKey, standard DKIM recovery is not possible\n  // we leave the defaults empty and the user will have to rely on\n  // keys added through DNSSEC\n  const selector = hexlify(toUtf8Bytes(''))\n  const modulus = hexlify(toUtf8Bytes(''))\n  const exponent = hexlify(toUtf8Bytes(''))\n  // if (dkimKey) {\n  //   const key = publicKeyToComponents(dkimKey.publicKey)\n  //   modulus = hexlify(key.modulus)\n  //   exponent = hexlify(toBeHex(key.exponent))\n  // }\n\n  // acceptUnknownSelectors should be always true\n  // and should not be overriden by the FE at this point\n  const acceptUnknownSelectors = RECOVERY_DEFAULTS.acceptUnknownSelectors\n  const waitUntilAcceptAdded =\n    recoveryInfo.waitUntilAcceptAdded ?? RECOVERY_DEFAULTS.waitUntilAcceptAdded\n  const waitUntilAcceptRemoved =\n    recoveryInfo.waitUntilAcceptRemoved ?? RECOVERY_DEFAULTS.waitUntilAcceptRemoved\n  const acceptEmptyDKIMSig = recoveryInfo.acceptEmptyDKIMSig ?? RECOVERY_DEFAULTS.acceptEmptyDKIMSig\n  const acceptEmptySecondSig =\n    recoveryInfo.acceptEmptySecondSig ?? RECOVERY_DEFAULTS.acceptEmptySecondSig\n  const onlyOneSigTimelock = recoveryInfo.onlyOneSigTimelock ?? RECOVERY_DEFAULTS.onlyOneSigTimelock\n\n  const abiCoder = new AbiCoder()\n  const validatorAddr = DKIM_VALIDATOR_ADDR\n  const validatorData = abiCoder.encode(\n    ['tuple(string,string,string,bytes,bytes,address,bool,uint32,uint32,bool,bool,uint32)'],\n    [\n      [\n        recoveryInfo.emailFrom,\n        RECOVERY_DEFAULTS.emailTo,\n        selector,\n        modulus,\n        exponent,\n        recoveryInfo.secondaryKey,\n        acceptUnknownSelectors,\n        waitUntilAcceptAdded,\n        waitUntilAcceptRemoved,\n        acceptEmptyDKIMSig,\n        acceptEmptySecondSig,\n        onlyOneSigTimelock\n      ]\n    ]\n  )\n  const { hash } = getSignerKey(validatorAddr, validatorData)\n  const privileges = [{ addr: associatedKey, hash }]\n  return getSmartAccount(privileges, [])\n}\n\nexport const isAmbireV1LinkedAccount = (factoryAddr?: string) =>\n  factoryAddr && getAddress(factoryAddr) === '0xBf07a0Df119Ca234634588fbDb5625594E2a5BCA'\n\nexport const isSmartAccount = (account?: Account | null) => !!account && !!account.creation\n\n/**\n * Checks if a (basic) EOA account is a derived one,\n * that is meant to be used as a smart account key only.\n */\nexport const isDerivedForSmartAccountKeyOnly = (index?: number) =>\n  typeof index === 'number' && index >= SMART_ACCOUNT_SIGNER_KEY_DERIVATION_OFFSET\n\nexport const getDefaultSelectedAccount = (accounts: Account[]) => {\n  if (accounts.length === 0) return null\n\n  const smartAccounts = accounts.filter((acc) => acc.creation)\n  if (smartAccounts.length) return smartAccounts[0]\n\n  return accounts[0]\n}\n\nexport const getAccountImportStatus = ({\n  account,\n  alreadyImportedAccounts,\n  keys,\n  accountsOnPage = [],\n  keyIteratorType\n}: {\n  account: Account\n  alreadyImportedAccounts: Account[]\n  keys: Key[]\n  accountsOnPage?: Omit<AccountOnPage, 'importStatus'>[]\n  keyIteratorType?: KeyIterator['type']\n}): ImportStatus => {\n  const isAlreadyImported = alreadyImportedAccounts.some(({ addr }) => addr === account.addr)\n  if (!isAlreadyImported) return ImportStatus.NotImported\n\n  // Check if the account has been imported with at least one of the keys\n  // that the account was originally associated with, when it was imported.\n  const storedAssociatedKeys =\n    alreadyImportedAccounts.find((x) => x.addr === account.addr)?.associatedKeys || []\n  const importedKeysForThisAcc = keys.filter((key) => storedAssociatedKeys.includes(key.addr))\n  // Could be imported as a view only account (and therefore, without a key)\n  if (!importedKeysForThisAcc.length) return ImportStatus.ImportedWithoutKey\n\n  // Merge the `associatedKeys` from the account instances found on the page,\n  // with the `associatedKeys` of the account from the extension storage. This\n  // ensures up-to-date keys, considering the account existing associatedKeys\n  // could be outdated  (associated keys of the smart accounts can change) or\n  // incomplete initial data (during the initial import, not all associatedKeys\n  // could have been fetched (for privacy).\n  const mergedAssociatedKeys = Array.from(\n    new Set([\n      ...accountsOnPage\n        .filter((x) => x.account.addr === account.addr)\n        .flatMap((x) => x.account.associatedKeys),\n      ...storedAssociatedKeys\n    ])\n  )\n\n  // Same key in this context means not only the same key address, but the\n  // same type too. Because user can opt in to import same key address with\n  // many different hardware wallets (Trezor, Ledger, GridPlus, etc.) or\n  // the same address with seed (private key).\n  const associatedKeysAlreadyImported = importedKeysForThisAcc.filter(\n    (key) =>\n      mergedAssociatedKeys.includes(key.addr) &&\n      // if key type is not provided, skip this part of the check on purpose\n      (keyIteratorType ? key.type === keyIteratorType : true)\n  )\n  if (associatedKeysAlreadyImported.length) {\n    const associatedKeysNotImportedYet = mergedAssociatedKeys.filter((keyAddr) =>\n      associatedKeysAlreadyImported.some((x) => x.addr !== keyAddr)\n    )\n\n    const notImportedYetKeysExistInPage = accountsOnPage.some((x) =>\n      associatedKeysNotImportedYet.includes(x.account.addr)\n    )\n\n    if (notImportedYetKeysExistInPage) return ImportStatus.ImportedWithSomeOfTheKeys\n\n    // Could happen when user imports a smart account with one associated key.\n    // Then imports an Basic account. Then makes the Basic account a second key\n    // for the smart account. In this case, both associated keys of the smart\n    // account are imported, but the smart account's `associatedKeys` are incomplete.\n    const associatedKeysFoundOnPageAreDifferent = accountsOnPage\n      .filter((x) => x.account.addr === account.addr)\n      .some((x) => {\n        const incomingAssociatedKeysSet = new Set(x.account.associatedKeys)\n        const storedAssociatedKeysSet = new Set(storedAssociatedKeys)\n\n        return ![...incomingAssociatedKeysSet].every((k) => storedAssociatedKeysSet.has(k))\n      })\n\n    return associatedKeysFoundOnPageAreDifferent\n      ? ImportStatus.ImportedWithSomeOfTheKeys\n      : ImportStatus.ImportedWithTheSameKeys\n  }\n\n  // Since there are `importedKeysForThisAcc`, as a fallback -\n  // for all other scenarios this account has been imported with different keys.\n  return ImportStatus.ImportedWithDifferentKeys\n}\n\nexport const getDefaultAccountPreferences = (\n  accountAddr: string,\n  prevAccounts: Account[],\n  i?: number\n): AccountPreferences => {\n  const number = i ? prevAccounts.length + (i + 1) : prevAccounts.length + 1\n\n  return {\n    label: `Account ${number}`,\n    pfp: getAddress(accountAddr) // default pfp - a jazz icon generated from the addr\n  }\n}\n\n// As of version 4.25.0, a new Account interface has been introduced,\n// merging the previously separate Account and AccountPreferences interfaces.\n// This change requires a migration due to the introduction of a new controller, AccountsController,\n// which now manages both accounts and their preferences.\nexport function migrateAccountPreferencesToAccounts(\n  accountPreferences: {\n    [key: AccountId]: AccountPreferences\n  },\n  accounts: Account[]\n) {\n  return accounts.map((a) => {\n    return {\n      ...a,\n      preferences: accountPreferences[a.addr] || { label: DEFAULT_ACCOUNT_LABEL, pfp: a.addr }\n    }\n  })\n}\n\nexport function getUniqueAccountsArray(accounts: Account[]) {\n  return Array.from(new Map(accounts.map((account) => [account.addr, account])).values())\n}\n"]}