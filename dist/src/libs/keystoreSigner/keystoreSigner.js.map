{"version":3,"file":"keystoreSigner.js","sourceRoot":"","sources":["../../../../src/libs/keystoreSigner/keystoreSigner.ts"],"names":[],"mappings":"AAAA,4BAA4B;AAC5B,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAsB,MAAM,EAAE,MAAM,QAAQ,CAAA;AAK1E,MAAM,OAAO,cAAc;IACzB,GAAG,CAAK;IAER,OAAO,CAAQ;IAEf,YAAY,IAAS,EAAE,QAAiB;QACtC,IAAI,CAAC,IAAI;YAAE,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAA;QAC5E,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,KAAK,CAAC,kEAAkE,CAAC,CAAA;QAErF,IAAI,CAAC,GAAG,GAAG,IAAI,CAAA;QACf,IAAI,CAAC,OAAO,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAA;IACrC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,MAA0B;QACjD,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC,CAAA;QAEtD,OAAO,GAAG,CAAA;IACZ,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,YAA0B;QAC5C,sGAAsG;QACtG,IAAI,YAAY,CAAC,KAAK,CAAC,YAAY,EAAE;YACnC,6CAA6C;YAC7C,OAAO,YAAY,CAAC,KAAK,CAAC,YAAY,CAAA;SACvC;QACD,aAAa;QACb,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,aAAa,CAC1C,YAAY,CAAC,MAAM,EACnB,YAAY,CAAC,KAAK,EAClB,YAAY,CAAC,OAAO,CACrB,CAAA;QAED,OAAO,GAAG,CAAA;IACZ,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,GAAW;QAC3B,gDAAgD;QAChD,yDAAyD;QACzD,mBAAmB;QACnB,mBAAmB;QACnB,sDAAsD;QACtD,qDAAqD;QACrD,uEAAuE;QACvE,qDAAqD;QACrD,+DAA+D;QAC/D,4DAA4D;QAC5D,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAA;SAC3E;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAA;IAChD,CAAC;IAED,KAAK,CAAC,eAAe,CAAC,WAA+B;QACnD,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,CAAA;QAEtE,OAAO,cAAc,CAAA;IACvB,CAAC;CACF","sourcesContent":["/* eslint-disable new-cap */\nimport { getBytes, isHexString, TransactionRequest, Wallet } from 'ethers'\n\nimport { Key, KeystoreSigner as KeystoreSignerInterface } from '../../interfaces/keystore'\nimport { TypedMessage } from '../../interfaces/userRequest'\n\nexport class KeystoreSigner implements KeystoreSignerInterface {\n  key: Key\n\n  #signer: Wallet\n\n  constructor(_key: Key, _privKey?: string) {\n    if (!_key) throw new Error('keystoreSigner: no key provided in constructor')\n    if (!_privKey)\n      throw new Error('keystoreSigner: no decrypted private key provided in constructor')\n\n    this.key = _key\n    this.#signer = new Wallet(_privKey)\n  }\n\n  async signRawTransaction(params: TransactionRequest) {\n    const sig = await this.#signer.signTransaction(params)\n\n    return sig\n  }\n\n  async signTypedData(typedMessage: TypedMessage) {\n    // remove EIP712Domain because otherwise signTypedData throws: ambiguous primary types or unused types\n    if (typedMessage.types.EIP712Domain) {\n      // eslint-disable-next-line no-param-reassign\n      delete typedMessage.types.EIP712Domain\n    }\n    // @ts-ignore\n    const sig = await this.#signer.signTypedData(\n      typedMessage.domain,\n      typedMessage.types,\n      typedMessage.message\n    )\n\n    return sig\n  }\n\n  async signMessage(hex: string): Promise<string> {\n    // interface implementation expects a hex number\n    // if something different is passed, we have two options:\n    // * throw an error\n    // * convert to hex\n    // converting to hex is not so straightforward, though\n    // you might do ethers.toUtf8Bytes() if it's a string\n    // or you might do ethers.toBeHex() for a number with a specific length\n    // or you might do ethers.hexlify() if you don't care\n    // therefore, it's the job of the client to think what he wants\n    // to pass. Throwing an error here might save debuging hours\n    if (!isHexString(hex)) {\n      throw new Error('Keystore signer, signMessage: passed value is not a hex')\n    }\n\n    return this.#signer.signMessage(getBytes(hex))\n  }\n\n  async sendTransaction(transaction: TransactionRequest) {\n    const transactionRes = await this.#signer.sendTransaction(transaction)\n\n    return transactionRes\n  }\n}\n"]}