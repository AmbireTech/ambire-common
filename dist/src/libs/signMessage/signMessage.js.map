{"version":3,"file":"signMessage.js","sourceRoot":"","sources":["../../../../src/libs/signMessage/signMessage.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport {\n  AbiCoder,\n  getAddress,\n  getBytes,\n  hashMessage,\n  hexlify,\n  Interface,\n  isHexString,\n  JsonRpcProvider,\n  toBeHex,\n  toUtf8Bytes,\n  TypedDataDomain,\n  TypedDataEncoder,\n  TypedDataField\n} from 'ethers'\n\nimport UniversalSigValidator from '../../../contracts/compiled/UniversalSigValidator.json'\nimport { PERMIT_2_ADDRESS, UNISWAP_UNIVERSAL_ROUTERS } from '../../consts/addresses'\nimport { Account, AccountCreation, AccountId, AccountOnchainState } from '../../interfaces/account'\nimport { Hex } from '../../interfaces/hex'\nimport { KeystoreSigner } from '../../interfaces/keystore'\nimport { Network } from '../../interfaces/network'\nimport { TypedMessage } from '../../interfaces/userRequest'\nimport hexStringToUint8Array from '../../utils/hexStringToUint8Array'\nimport isSameAddr from '../../utils/isSameAddr'\nimport { stripHexPrefix } from '../../utils/stripHexPrefix'\nimport {\n  AccountOp,\n  accountOpSignableHash,\n  callToTuple,\n  getSignableHash\n} from '../accountOp/accountOp'\nimport { fromDescriptor } from '../deployless/deployless'\nimport { relayerAdditionalNetworks } from '../networks/networks'\nimport { getActivatorCall } from '../userOperation/userOperation'\n\n// EIP6492 signature ends in magicBytes, which ends with a 0x92,\n// which makes it is impossible for it to collide with a valid ecrecover signature if packed in the r,s,v format,\n// as 0x92 is not a valid value for v.\nconst magicBytes = '6492649264926492649264926492649264926492649264926492649264926492'\n\nexport const EIP_1271_NOT_SUPPORTED_BY = [\n  'opensea.io',\n  'paraswap.xyz',\n  'blur.io',\n  'aevo.xyz',\n  'socialscan.io',\n  'tally.xyz',\n  'questn.com'\n]\n\n/**\n * For Unprotected signatures, we need to append 00 at the end\n * for ambire to recognize it\n */\nexport const wrapUnprotected = (signature: string) => {\n  return `${signature}00`\n}\n\n/**\n * For EIP-712 signatures, we need to append 01 at the end\n * for ambire to recognize it.\n * For v1 contracts, we do ETH sign at the 01 slot, which we'll\n * call standard from now on\n */\nexport const wrapStandard = (signature: string) => {\n  return `${signature}01`\n}\n\n/**\n * For v2 accounts acting as signers, we need to append the v2 wallet\n * addr that's the signer and a 02 mode at the end to indicate it's a wallet:\n * {sig+mode}{wallet_32bytes}{mode}\n */\nexport const wrapWallet = (signature: string, walletAddr: string) => {\n  const wallet32bytes = `${stripHexPrefix(toBeHex(0, 12))}${stripHexPrefix(walletAddr)}`\n  return `${signature}${wallet32bytes}02`\n}\n\n// allow v1 accounts to have v2 signers\ninterface AmbireReadableOperation {\n  addr: Hex\n  chainId: bigint\n  nonce: bigint\n  calls: { to: Hex; value: bigint; data: Hex }[]\n}\n\nexport const getAmbireReadableTypedData = (\n  chainId: bigint,\n  verifyingAddr: string,\n  v1Execute: AmbireReadableOperation\n): TypedMessage => {\n  const domain: TypedDataDomain = {\n    name: 'Ambire',\n    version: '1',\n    chainId: chainId.toString(),\n    verifyingContract: verifyingAddr,\n    salt: toBeHex(0, 32)\n  }\n  const types = {\n    EIP712Domain: [\n      {\n        name: 'name',\n        type: 'string'\n      },\n      {\n        name: 'version',\n        type: 'string'\n      },\n      {\n        name: 'chainId',\n        type: 'uint256'\n      },\n      {\n        name: 'verifyingContract',\n        type: 'address'\n      },\n      {\n        name: 'salt',\n        type: 'bytes32'\n      }\n    ],\n    Calls: [\n      { name: 'to', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'data', type: 'bytes' }\n    ],\n    AmbireReadableOperation: [\n      { name: 'account', type: 'address' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'calls', type: 'Calls[]' }\n    ]\n  }\n\n  return {\n    kind: 'typedMessage',\n    domain,\n    types,\n    message: v1Execute,\n    primaryType: 'AmbireOperation'\n  }\n}\n\n/**\n * Return the typed data for EIP-712 sign\n */\nexport const getTypedData = (\n  chainId: bigint,\n  verifyingAddr: string,\n  msgHash: string\n): TypedMessage => {\n  const domain: TypedDataDomain = {\n    name: 'Ambire',\n    version: '1',\n    chainId: chainId.toString(),\n    verifyingContract: verifyingAddr,\n    salt: toBeHex(0, 32)\n  }\n  const types = {\n    EIP712Domain: [\n      {\n        name: 'name',\n        type: 'string'\n      },\n      {\n        name: 'version',\n        type: 'string'\n      },\n      {\n        name: 'chainId',\n        type: 'uint256'\n      },\n      {\n        name: 'verifyingContract',\n        type: 'address'\n      },\n      {\n        name: 'salt',\n        type: 'bytes32'\n      }\n    ],\n    AmbireOperation: [\n      { name: 'account', type: 'address' },\n      { name: 'hash', type: 'bytes32' }\n    ]\n  }\n  const message = {\n    account: verifyingAddr,\n    hash: msgHash\n  }\n\n  return {\n    kind: 'typedMessage',\n    domain,\n    types,\n    message,\n    primaryType: 'AmbireOperation'\n  }\n}\n\n/**\n * Produce EIP6492 signature for Predeploy Contracts\n *\n * More info: https://eips.ethereum.org/EIPS/eip-6492\n *\n * @param {string} signature - origin ERC-1271 signature\n * @param {object} account\n * @returns {string} - EIP6492 signature\n */\nexport const wrapCounterfactualSign = (signature: string, creation: AccountCreation) => {\n  const ABI = ['function deploy(bytes code, uint256 salt)']\n  const iface = new Interface(ABI)\n  const factoryCallData = iface.encodeFunctionData('deploy', [creation.bytecode, creation.salt])\n\n  const coder = new AbiCoder()\n\n  // EIP6492 signature\n  return (\n    coder.encode(\n      ['address', 'bytes', 'bytes'],\n      [creation.factoryAddr, factoryCallData, signature]\n    ) + magicBytes\n  )\n}\n\nexport function mapSignatureV(sigRaw: string) {\n  const sig = hexStringToUint8Array(sigRaw)\n  if (sig[64] < 27) sig[64] += 27\n  return hexlify(sig)\n}\n\ntype Props = {\n  network?: Network\n  provider?: JsonRpcProvider\n  signer?: string\n  signature: string | Uint8Array\n  message?: string | Uint8Array\n  typedData?: {\n    domain: TypedDataDomain\n    types: Record<string, Array<TypedDataField>>\n    message: Record<string, any>\n  }\n  finalDigest?: string\n}\n\n/**\n * Verifies the signature of a message using the provided signer and signature\n * via a \"magic\" universal validator contract using the provided provider to\n * verify the signature on-chain. The contract deploys itself within the\n * `eth_call`, tries to verify the signature using ERC-6492, ERC-1271, and\n * `ecrecover`, and returns the value to the function.\n *\n * Note: you only need to pass one of: typedData, finalDigest, message\n */\nexport async function verifyMessage({\n  network,\n  provider,\n  signer,\n  signature,\n  message,\n  typedData,\n  finalDigest\n}: (\n  | Required<Pick<Props, 'message'>>\n  | Required<Pick<Props, 'typedData'>>\n  | Required<Pick<Props, 'finalDigest'>>\n) &\n  Props): Promise<boolean> {\n  if (message) {\n    try {\n      finalDigest = hashMessage(message)\n      if (!finalDigest) throw Error('Hashing the message returned no (falsy) result.')\n    } catch (e: any) {\n      throw Error(\n        `Preparing the just signed (standard) message for validation failed. Please try again or contact Ambire support if the issue persists. Error details: ${\n          e?.message || 'missing'\n        }`\n      )\n    }\n  } else if (typedData) {\n    // To resolve the \"ambiguous primary types or unused types\" error, remove\n    // the `EIP712Domain` from `types` object. The domain type is inbuilt in\n    // the EIP712 standard and hence TypedDataEncoder so you do not need to\n    // specify it in the types, see:\n    // {@link https://ethereum.stackexchange.com/a/151930}\n    const typesWithoutEIP712Domain = { ...typedData.types }\n    if (typesWithoutEIP712Domain.EIP712Domain) {\n      // eslint-disable-next-line no-param-reassign\n      delete typesWithoutEIP712Domain.EIP712Domain\n    }\n\n    try {\n      // the final digest for AmbireReadableOperation is the execute hash\n      // as it's wrapped in mode.standard and onchain gets transformed to\n      // an AmbireOperation\n      if ('AmbireReadableOperation' in typedData.types) {\n        const ambireReadableOperation = typedData.message as AmbireReadableOperation\n        finalDigest = hexlify(\n          getSignableHash(\n            ambireReadableOperation.addr,\n            ambireReadableOperation.chainId,\n            ambireReadableOperation.nonce,\n            ambireReadableOperation.calls.map(callToTuple)\n          )\n        )\n      } else {\n        finalDigest = TypedDataEncoder.hash(\n          typedData.domain,\n          typesWithoutEIP712Domain,\n          typedData.message\n        )\n      }\n\n      if (!finalDigest) throw Error('Hashing the typedData returned no (falsy) result.')\n    } catch (e: any) {\n      throw Error(\n        `Preparing the just signed (typed data) message for validation failed. Please try again or contact Ambire support if the issue persists. Error details: ${\n          e?.message || 'missing'\n        }`\n      )\n    }\n  }\n\n  // this 'magic' universal validator contract will deploy itself within the eth_call, try to verify the signature using\n  // ERC-6492, ERC-1271 and ecrecover, and return the value to us\n  const coder = new AbiCoder()\n  let callResult\n  try {\n    const deploylessVerify = fromDescriptor(\n      provider!,\n      UniversalSigValidator,\n      !network!.rpcNoStateOverride\n    )\n    const deploylessRes = await deploylessVerify.call('isValidSigWithSideEffects', [\n      signer,\n      finalDigest,\n      signature\n    ])\n    if (deploylessRes[0] === true) callResult = '0x01'\n    else if (deploylessRes[0] === false) callResult = '0x00'\n    else callResult = deploylessRes[0]\n  } catch (e: any) {\n    throw new Error(\n      `Validating the just signed message failed. Please try again or contact Ambire support if the issue persists. Error details: UniversalValidator call failed, more details: ${\n        // TODO: Use the `reason` from the decodeError(e) instead, when this case is better handled in there\n        e?.message || 'missing'\n      }`\n    )\n  }\n\n  if (callResult === '0x01') return true\n  if (callResult === '0x00') return false\n  if (callResult.startsWith('0x08c379a0'))\n    throw new Error(\n      `Ambire failed to validate the signature. Please make sure you are signing with the correct key or device. If the problem persists, please contact Ambire support. Error details:: ${\n        coder.decode(['string'], `0x${callResult.slice(10)}`)[0]\n      }`\n    )\n\n  throw new Error(\n    `Ambire failed to validate the signature. Please make sure you are signing with the correct key or device. If the problem persists, please contact Ambire support. Error details: unexpected result from the UniversalValidator: ${callResult}`\n  )\n}\n\n// Authorize the execute calls according to the version of the smart account\nexport async function getExecuteSignature(\n  network: Network,\n  accountOp: AccountOp,\n  accountState: AccountOnchainState,\n  signer: KeystoreSigner\n) {\n  // if we're authorizing calls for a v1 contract, we do a sign message\n  // on the hash of the calls\n  if (!accountState.isV2) {\n    const message = hexlify(accountOpSignableHash(accountOp, network.chainId))\n    return wrapStandard(await signer.signMessage(message))\n  }\n\n  // txns for v2 contracts are always eip-712 so we put the hash of the calls\n  // in eip-712 format\n  const typedData = getTypedData(\n    network.chainId,\n    accountState.accountAddr,\n    hexlify(accountOpSignableHash(accountOp, network.chainId))\n  )\n  return wrapStandard(await signer.signTypedData(typedData))\n}\n\nexport async function getPlainTextSignature(\n  message: string | Uint8Array,\n  network: Network,\n  account: Account,\n  accountState: AccountOnchainState,\n  signer: KeystoreSigner\n): Promise<string> {\n  const dedicatedToOneSA = signer.key.dedicatedToOneSA\n\n  let messageHex\n  if (message instanceof Uint8Array) {\n    messageHex = hexlify(message)\n  } else if (!isHexString(message)) {\n    messageHex = hexlify(toUtf8Bytes(message))\n  } else {\n    messageHex = message\n  }\n\n  if (!account.creation) {\n    const signature = await signer.signMessage(messageHex)\n    return signature\n  }\n\n  if (!accountState.isV2) {\n    const lowercaseHexAddrWithout0x = hexlify(toUtf8Bytes(account.addr.toLowerCase().slice(2)))\n    const checksummedHexAddrWithout0x = hexlify(toUtf8Bytes(account.addr.slice(2)))\n    const asciiAddrLowerCase = account.addr.toLowerCase()\n    const humanReadableMsg = message instanceof Uint8Array ? hexlify(message) : message\n\n    const isAsciiAddressInMessage = humanReadableMsg.toLowerCase().includes(asciiAddrLowerCase)\n    const isLowercaseHexAddressInMessage = humanReadableMsg.includes(\n      lowercaseHexAddrWithout0x.slice(2)\n    )\n    const isChecksummedHexAddressInMessage = humanReadableMsg.includes(\n      checksummedHexAddrWithout0x.slice(2)\n    )\n\n    if (\n      !network.predefined &&\n      !relayerAdditionalNetworks.find((net) => net.chainId === network.chainId)\n    ) {\n      throw new Error(`Signing messages is disallowed for v1 accounts on ${network.name}`)\n    }\n\n    if (\n      isAsciiAddressInMessage ||\n      isLowercaseHexAddressInMessage ||\n      isChecksummedHexAddressInMessage\n    ) {\n      return wrapUnprotected(await signer.signMessage(messageHex))\n    }\n\n    throw new Error(\n      'Signing messages is disallowed for v1 accounts. Please contact support to proceed'\n    )\n  }\n\n  // if it's safe, we proceed\n  if (dedicatedToOneSA) {\n    return wrapUnprotected(await signer.signMessage(messageHex))\n  }\n\n  // in case of only_standard priv key, we transform the data\n  // for signing to EIP-712. This is because the key is not labeled safe\n  // and it should inform the user that he's performing an Ambire Op.\n  // This is important as this key could be a metamask one and someone\n  // could be phishing him into approving an Ambire Op without him\n  // knowing\n  const typedData = getTypedData(network!.chainId, account.addr, hashMessage(getBytes(messageHex)))\n  return wrapStandard(await signer.signTypedData(typedData))\n}\n\nexport async function getEIP712Signature(\n  message: TypedMessage,\n  account: Account,\n  accountState: AccountOnchainState,\n  signer: KeystoreSigner,\n  network: Network\n): Promise<string> {\n  if (!message.types.EIP712Domain) {\n    throw new Error(\n      'Ambire only supports signing EIP712 typed data messages. Please try again with a valid EIP712 message.'\n    )\n  }\n  if (!message.primaryType) {\n    throw new Error(\n      'The primaryType is missing in the typed data message incoming. Please try again with a valid EIP712 message.'\n    )\n  }\n\n  if (!account.creation) {\n    const signature = await signer.signTypedData(message)\n    return signature\n  }\n\n  if (!accountState.isV2) {\n    const asString = JSON.stringify(message).toLowerCase()\n    if (\n      asString.indexOf(account.addr.toLowerCase()) !== -1 ||\n      (message.domain.name === 'Permit2' &&\n        message.domain.verifyingContract &&\n        getAddress(message.domain.verifyingContract) === PERMIT_2_ADDRESS &&\n        message.message &&\n        message.message.spender &&\n        UNISWAP_UNIVERSAL_ROUTERS[Number(network.chainId)] &&\n        UNISWAP_UNIVERSAL_ROUTERS[Number(network.chainId)] === getAddress(message.message.spender))\n    ) {\n      return wrapUnprotected(await signer.signTypedData(message))\n    }\n\n    throw new Error(\n      'Signing this eip-712 message is disallowed for v1 accounts as it does not contain the smart account address and therefore deemed unsafe'\n    )\n  }\n\n  // we do not allow signers who are not dedicated to one account to sign eip-712\n  // messsages in v2 as it could lead to reusing that key from\n  const dedicatedToOneSA = signer.key.dedicatedToOneSA\n  if (!dedicatedToOneSA) {\n    throw new Error(\n      `Signer with address ${signer.key.addr} does not have privileges to execute this operation. Please choose a different signer and try again`\n    )\n  }\n\n  if ('AmbireReadableOperation' in message.types) {\n    const ambireReadableOperation = message.message as AmbireReadableOperation\n    if (isSameAddr(ambireReadableOperation.addr, account.addr)) {\n      throw new Error(\n        'signature error: trying to sign an AmbireReadableOperation for the same address. Please contact support'\n      )\n    }\n\n    const hash = hexlify(\n      getSignableHash(\n        ambireReadableOperation.addr,\n        ambireReadableOperation.chainId,\n        ambireReadableOperation.nonce,\n        ambireReadableOperation.calls.map(callToTuple)\n      )\n    )\n    const ambireOperation = getTypedData(ambireReadableOperation.chainId, account.addr, hash)\n    const signature = wrapStandard(await signer.signTypedData(ambireOperation))\n    return wrapWallet(signature, account.addr)\n  }\n\n  return wrapUnprotected(await signer.signTypedData(message))\n}\n\n// get the typedData for the first ERC-4337 deploy txn\nexport async function getEntryPointAuthorization(addr: AccountId, chainId: bigint, nonce: bigint) {\n  const hash = getSignableHash(addr, chainId, nonce, [callToTuple(getActivatorCall(addr))])\n  return getTypedData(chainId, addr, hexlify(hash))\n}\n\nexport function adjustEntryPointAuthorization(signature: string): string {\n  let entryPointSig = signature\n\n  // if thet signature is wrapepd in magicBytes because of eip-6492, unwrap it\n  if (signature.endsWith(magicBytes)) {\n    const coder = new AbiCoder()\n    const decoded = coder.decode(\n      ['address', 'bytes', 'bytes'],\n      signature.substring(0, signature.length - magicBytes.length)\n    )\n    entryPointSig = decoded[2]\n  }\n\n  // since normally when we sign an EIP-712 request, we wrap it in Unprotected,\n  // we adjust the entry point authorization signature so we could execute a txn\n  return wrapStandard(entryPointSig.substring(0, entryPointSig.length - 2))\n}\n"]}