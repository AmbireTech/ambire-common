{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../src/libs/humanizer/modules/OpenSea/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Interface } from 'ethers'\n\nimport { AccountOp } from '../../../accountOp/accountOp'\nimport { stringify } from '../../../richJson/richJson'\nimport { HumanizerCallModule, IrCall } from '../../interfaces'\nimport { getAction, getAddressVisualization, getDeadline, getLabel, getToken } from '../../utils'\n\nconst iface = new Interface([\n  'function fulfillBasicOrder_efficient_6GL6yc(tuple(address considerationToken, uint256 considerationIdentifier, uint256 considerationAmount, address offerer, address zone, address offerToken, uint256 offerIdentifier, uint256 offerAmount, uint8 basicOrderType, uint256 startTime, uint256 endTime, bytes32 zoneHash, uint256 salt, bytes32 offererConduitKey, bytes32 fulfillerConduitKey, uint256 totalOriginalAdditionalRecipients, tuple(uint256 amount, address recipient)[] additionalRecipients, bytes signature) args) payable returns (bool fulfilled)',\n  'function fulfillBasicOrder(tuple(address considerationToken, uint256 considerationIdentifier, uint256 considerationAmount, address offerer, address zone, address offerToken, uint256 offerIdentifier, uint256 offerAmount, uint8 basicOrderType, uint256 startTime, uint256 endTime, bytes32 zoneHash, uint256 salt, bytes32 offererConduitKey, bytes32 fulfillerConduitKey, uint256 totalOriginalAdditionalRecipients, tuple(uint256 amount, address recipient)[] additionalRecipients, bytes signature) args) payable returns (bool fulfilled)',\n  'function fulfillAvailableAdvancedOrders(((address offerer, address zone, (uint8 itemType, address token, uint256 identifierOrCriteria, uint256 startAmount, uint256 endAmount)[] offer, (uint8 itemType, address token, uint256 identifierOrCriteria, uint256 startAmount, uint256 endAmount, address recipient)[] consideration, uint8 orderType, uint256 startTime, uint256 endTime, bytes32 zoneHash, uint256 salt, bytes32 conduitKey, uint256 totalOriginalConsiderationItems) parameters, uint120 numerator, uint120 denominator, bytes signature, bytes extraData)[], (uint256 orderIndex, uint8 side, uint256 index, uint256 identifier, bytes32[] criteriaProof)[], (uint256 orderIndex, uint256 itemIndex)[][], (uint256 orderIndex, uint256 itemIndex)[][], bytes32 fulfillerConduitKey, address recipient, uint256 maximumFulfilled) payable returns (bool[], ((uint8 itemType, address token, uint256 identifier, uint256 amount, address recipient) item, address offerer, bytes32 conduitKey)[])',\n  'function fulfillAdvancedOrder(((address offerer, address zone, (uint8 itemType, address token, uint256 identifierOrCriteria, uint256 startAmount, uint256 endAmount)[] offer, (uint8 itemType, address token, uint256 identifierOrCriteria, uint256 startAmount, uint256 endAmount, address recipient)[] consideration, uint8 orderType, uint256 startTime, uint256 endTime, bytes32 zoneHash, uint256 salt, bytes32 conduitKey, uint256 totalOriginalConsiderationItems) parameters, uint120 numerator, uint120 denominator, bytes signature, bytes extraData), (uint256 orderIndex, uint8 side, uint256 index, uint256 identifier, bytes32[] criteriaProof)[], bytes32 fulfillerConduitKey, address recipient) payable returns (bool fulfilled)'\n])\n\ninterface Order {\n  items: { address: string; id: bigint; fromAmount: bigint; endAmount: bigint }[]\n  payment: { address: string; amountOrId: bigint }[]\n  end: bigint\n}\nconst parsePrice = (price: bigint, numerator: bigint, denumerator: bigint): bigint =>\n  BigInt((price * numerator) / denumerator)\nconst parseOrder = (order: any): Order => {\n  const [\n    params,\n    num,\n    denum\n    // data2, data3\n  ] = order\n  const [\n    ,\n    ,\n    // currentOwner\n    // zone\n    offers,\n    consideration,\n    ,\n    ,\n    // orderType\n    // startTime\n    endTime\n    // zoneHash,\n    // salt,\n    // conduitKey\n    // totalOriginalConsiderationItems\n  ] = params\n  const items = offers.map((o: any): Order['items'][0] => {\n    const [\n      ,\n      // type\n      address,\n      id,\n      fromAmount,\n      endAmount\n    ] = o\n    return {\n      address,\n      id,\n      fromAmount: parsePrice(fromAmount, num, denum),\n      endAmount: parsePrice(endAmount, num, denum)\n    }\n  })\n  const payment: Order['payment'][0][] = []\n  const tokenPayments: { [addr: string]: bigint } = {}\n  consideration.forEach((o: any) => {\n    const [\n      type,\n      token,\n      tokenId,\n      ,\n      // fromAmount\n      endAmount\n    ] = o\n    if (type === 0n || type === 1n)\n      tokenPayments[token] = (tokenPayments[token] || 0n) + parsePrice(endAmount, num, denum)\n    if (type === 2n || type === 3n)\n      payment.push({ address: token as string, amountOrId: BigInt(tokenId) })\n  })\n  Object.entries(tokenPayments).forEach(([address, amountOrId]) => {\n    payment.push({ address, amountOrId })\n  })\n  return { items, payment, end: BigInt(endTime) }\n}\n\nconst dedupe1155Orders = (orders: Order[]): any[] => {\n  if (orders.length <= 30) return orders\n  const uniqueOrders = [...new Set(orders.map(stringify))]\n  if (uniqueOrders.length > 1) return orders\n  if (orders[0].items.length > 1) return orders\n  if (orders[0].payment.length > 1) return orders\n  // if (uniqueOrders.items.length > 1) return orders\n  const correctNumberOfOrders = BigInt(orders.length - 30)\n  const finalOrder = orders[0]\n  finalOrder.items[0].endAmount *= correctNumberOfOrders\n  finalOrder.items[0].fromAmount *= correctNumberOfOrders\n  finalOrder.payment[0].amountOrId *= correctNumberOfOrders\n  return [finalOrder]\n}\nconst humanizerOrder = ({ items, payment, end }: Order) => {\n  return [\n    getAction('Buy'),\n    ...items\n      .map(({ address, id, fromAmount }) =>\n        fromAmount === 1n\n          ? [getToken(address, id)]\n          : [getLabel(fromAmount.toString(), true), getToken(address, id)]\n      )\n      .flat(),\n    getLabel('for up to'),\n    ...payment.map(({ address, amountOrId }) => getToken(address, amountOrId)),\n    getDeadline(end)\n  ]\n}\n\nexport const openSeaModule: HumanizerCallModule = (accountOp: AccountOp, irCalls: IrCall[]) => {\n  return irCalls.map((call: IrCall) => {\n    if (\n      [\n        iface.getFunction('fulfillBasicOrder_efficient_6GL6yc')!.selector,\n        iface.getFunction('fulfillBasicOrder')!.selector\n      ].includes(call.data.slice(0, 10))\n    ) {\n      let orders\n      if (call.data.slice(0, 10) === iface.getFunction('fulfillBasicOrder')!.selector)\n        orders = iface.decodeFunctionData('fulfillBasicOrder', call.data)\n      else orders = iface.decodeFunctionData('fulfillBasicOrder_efficient_6GL6yc', call.data)\n\n      const data = orders.map((i) => {\n        const [\n          considerationToken,\n          considerationIdentifier,\n          considerationAmount,\n          ,\n          ,\n          // offerer,\n          // zone,\n          offerToken,\n          offerIdentifier,\n          ,\n          ,\n          // offerAmount,\n          // basicOrderType,\n          startTime,\n          endTime\n          // zoneHash,\n          // salt,\n          // offererConduitKey,\n          // fulfillerConduitKey,\n          // totalOriginalAdditionalRecipients,\n          // additionalRecipients,\n          // signature\n        ] = i\n\n        return {\n          considerationToken,\n          considerationIdentifier,\n          considerationAmount,\n          // offerer,\n          // zone,\n          offerToken,\n          offerIdentifier,\n          // offerAmount,\n          // basicOrderType,\n          startTime,\n          endTime\n          // zoneHash,\n          // salt,\n          // offererConduitKey,\n          // fulfillerConduitKey,\n          // totalOriginalAdditionalRecipients,\n          // additionalRecipients,\n          // signature\n        }\n      })\n      if (data.length !== 1) return call\n      return {\n        ...call,\n        fullVisualization: [\n          getAction('Buy'),\n          getToken(data[0].offerToken, data[0].offerIdentifier),\n          getLabel('for'),\n          getToken(data[0].considerationToken, data[0].considerationAmount),\n          getDeadline(data[0].endTime)\n        ]\n      }\n    }\n\n    if (call.data.startsWith(iface.getFunction('fulfillAvailableAdvancedOrders')!.selector)) {\n      const [orders] = iface.decodeFunctionData('fulfillAvailableAdvancedOrders', call.data)\n\n      let totalOrders: Order[] = orders.map((o: any) => parseOrder(o))\n      // opensea allows batch buy of 30 items at most\n      // if we detect more than 30 orders, that means the dapp attempts to\n      // execute n-30 EIP1155 orders that are being deduplicated accordingly on a contract level\n      // dedupe1155Orders removes 30 repeating orders and merges the remaining n orders\n      if (totalOrders.length > 30) totalOrders = dedupe1155Orders(totalOrders)\n      // still not deduped\n      if (totalOrders.length > 30)\n        return {\n          ...call,\n          fullVisualization: [\n            getAction('Buy NFTs'),\n            getLabel('from'),\n            getAddressVisualization(call.to)\n          ]\n        }\n      const fullVisualization = totalOrders.map(humanizerOrder).flat()\n      return { ...call, fullVisualization }\n    }\n    if (call.data.startsWith(iface.getFunction('fulfillAdvancedOrder')!.selector)) {\n      const [order] = iface.decodeFunctionData('fulfillAdvancedOrder', call.data)\n      const parsedOrder: Order = parseOrder(order)\n      const fullVisualization = humanizerOrder(parsedOrder)\n      return { ...call, fullVisualization }\n    }\n\n    return call\n  })\n}\n"]}