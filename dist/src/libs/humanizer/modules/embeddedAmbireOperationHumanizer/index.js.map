{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../src/libs/humanizer/modules/embeddedAmbireOperationHumanizer/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Interface, Result } from 'ethers'\n\nimport { AccountOp } from '../../../accountOp/accountOp'\nimport { AmbireAccount } from '../../const/abis/AmbireAccount'\nimport { HumanizerCallModule, HumanizerMeta, IrCall } from '../../interfaces'\nimport { getAction, getAddressVisualization, getLabel } from '../../utils'\n\n// the purpose of this module is simply to visualize attempts to hide ambire operations within the current account op\n// such thing can be done if the dapp requests a tryCatch/executeBySelfSingle/executeBySelf function call directed to the current account\n// this call will be executed without needing extra authentication. For more details check out AmbireAccount.sol\nexport const embeddedAmbireOperationHumanizer: HumanizerCallModule = (\n  accountOp: AccountOp,\n  irCalls: IrCall[]\n) => {\n  const iface = new Interface(AmbireAccount)\n  const matcher: { [selector: string]: (originalCall: IrCall) => IrCall[] } = {\n    [iface.getFunction('tryCatch')!.selector]: (originalCall: IrCall) => {\n      const { to, value, data } = iface.decodeFunctionData('tryCatch', originalCall.data)\n      return [{ ...originalCall, to, value, data }]\n    },\n    [iface.getFunction('tryCatchLimit')!.selector]: (originalCall: IrCall) => {\n      const { to, value, data } = iface.decodeFunctionData('tryCatchLimit', originalCall.data)\n      return [{ ...originalCall, to, value, data }]\n    },\n    [iface.getFunction('executeBySelfSingle')!.selector]: (originalCall: IrCall) => {\n      const {\n        call: { to, value, data }\n      } = iface.decodeFunctionData('executeBySelfSingle', originalCall.data)\n      return [{ ...originalCall, to, value, data }]\n    },\n    [iface.getFunction('executeBySelf')!.selector]: (originalCall: IrCall) => {\n      const { calls } = iface.decodeFunctionData('executeBySelf', originalCall.data)\n      // ethers returns Result type, which we do not want to leak in the result\n      return calls.map(({ to, value, data }: Result) => ({ ...originalCall, to, value, data }))\n    }\n  }\n  const functionSelectorsCallableFromSigner = ['execute', 'executeMultiple', 'executeBySender'].map(\n    (i) => iface.getFunction(i)!.selector\n  )\n  const functionSelectorsCallableFromSelf = [\n    'tryCatch',\n    'tryCatch',\n    'executeBySelfSingle',\n    'executeBySelf'\n  ].map((i) => iface.getFunction(i)!.selector)\n  const newCalls: IrCall[] = []\n\n  irCalls.forEach((call) => {\n    if (\n      call.to?.toLowerCase() === accountOp.accountAddr.toLowerCase() &&\n      matcher[call.data.slice(0, 10)]\n    ) {\n      newCalls.push(...matcher[call.data.slice(0, 10)](call))\n      return\n    }\n    if (functionSelectorsCallableFromSigner.includes(call.data.slice(0, 10))) {\n      newCalls.push({\n        ...call,\n        fullVisualization: [\n          getAction('Execute calls'),\n          getLabel('from'),\n          getAddressVisualization(call.to)\n        ]\n      })\n      return\n    }\n    newCalls.push(call)\n  })\n\n  // if an attacker hides some call deeper inside a method, callable from self\n  const hasParsableCalls = newCalls.some(\n    (call) =>\n      // we could unwrap more\n      functionSelectorsCallableFromSelf.includes(call.data.slice(0, 10)) ||\n      // an unwrapped call could get humanization here\n      (functionSelectorsCallableFromSigner.includes(call.data.slice(0, 10)) &&\n        !call.fullVisualization?.length)\n  )\n\n  return hasParsableCalls\n    ? embeddedAmbireOperationHumanizer(accountOp, newCalls, {} as HumanizerMeta)\n    : newCalls\n}\n"]}