{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../../src/libs/errorDecoder/helpers.ts"],"names":[],"mappings":";;;AAgHE,4CAAgB;AAhHlB,mCAAkD;AAElD,2CAA8D;AAE9D,MAAM,sBAAsB,GAAG,CAAC,SAAiB,EAAsB,EAAE;IACvE,QAAQ,SAAS,EAAE,CAAC;QAClB,KAAK,IAAI;YACP,OAAO,iCAAiC,CAAA;QAC1C,KAAK,IAAI;YACP,OAAO,iBAAiB,CAAA;QAC1B,KAAK,KAAK;YACR,OAAO,8EAA8E,CAAA;QACvF,KAAK,KAAK;YACR,OAAO,qCAAqC,CAAA;QAC9C,KAAK,KAAK;YACR,OAAO,8EAA8E,CAAA;QACvF,KAAK,KAAK;YACR,OAAO,wCAAwC,CAAA;QACjD,KAAK,KAAK;YACR,OAAO,qCAAqC,CAAA;QAC9C,KAAK,KAAK;YACR,OAAO,sDAAsD,CAAA;QAC/D,KAAK,KAAK;YACR,OAAO,0EAA0E,CAAA;QACnF,KAAK,KAAK;YACR,OAAO,8DAA8D,CAAA;QACvE;YACE,OAAO,SAAS,CAAA;IACpB,CAAC;AACH,CAAC,CAAA;AAgFC,wDAAsB;AA9ExB,MAAM,aAAa,GAAG,CAAC,MAAqB,EAAW,EAAE;IACvD,OAAO,CACL,CAAC,CAAC,MAAM;QACR,OAAO,MAAM,KAAK,QAAQ;QAC1B,MAAM,KAAK,IAAI;QACf,MAAM,KAAK,eAAe;QAC1B,MAAM,KAAK,eAAe;QAC1B,CAAC,MAAM,CAAC,UAAU,CAAC,wBAAY,CAAC;QAChC,CAAC,MAAM,CAAC,UAAU,CAAC,8BAAkB,CAAC;QACtC,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,0BAA0B,CAAC,CAC3D,CAAA;AACH,CAAC,CAAA;AAqEC,sCAAa;AAnEf;;GAEG;AACH,MAAM,6BAA6B,GAAG,CAAC,GAAW,EAAU,EAAE;IAC5D,IAAI,UAAU,GAAG,CAAC,CAAA;IAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACpC,MAAM,IAAI,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QAC1B,wEAAwE;QACxE,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YAC/B,UAAU,EAAE,CAAA;QACd,CAAC;IACH,CAAC;IACD,OAAO,UAAU,CAAA;AACnB,CAAC,CAAA;AAyDC,sEAA6B;AAvD/B;;;GAGG;AACH,MAAM,YAAY,GAAG,CAAC,MAAc,EAAU,EAAE;IAC9C,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,EAAE,CAAA;IACnC,IAAI,CAAC,IAAA,oBAAW,EAAC,aAAa,CAAC;QAAE,OAAO,aAAa,CAAA;IACrD,IAAI,aAAa,CAAC,UAAU,CAAC,wBAAY,CAAC,IAAI,aAAa,CAAC,UAAU,CAAC,8BAAkB,CAAC;QACxF,OAAO,aAAa,CAAA;IAEtB,IAAI,CAAC;QACH,MAAM,aAAa,GAAG,IAAA,qBAAY,EAAC,aAAa,CAAC,CAAA;QAEjD,iEAAiE;QACjE,OAAO,6BAA6B,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,aAAa,CAAA;IACzF,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,aAAa,CAAA;IACtB,CAAC;AACH,CAAC,CAAA;AAoCC,oCAAY;AAlCd,MAAM,4BAA4B,GAAG,CAAC,MAAe,EAAE,SAAS,GAAG,IAAI,EAAU,EAAE;IACjF,IAAI,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;QAAE,OAAO,EAAE,CAAA;IAEhD,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAA;IAEnF,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,eAAe,eAAe,EAAE,CAAA;AAChE,CAAC,CAAA;AAyBC,oEAA4B;AAvB9B,SAAS,gBAAgB,CAAC,KAAY;IACpC,8DAA8D;IAC9D,MAAM,SAAS,GAAI,KAAa,CAAC,IAAI,IAAK,KAAa,CAAC,KAAK,EAAE,IAAI,CAAA;IAEnE,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;QAC5B,OAAO,EAAE,CAAA;IACX,CAAC;IAED,IAAI,UAAU,GAAG,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAA;IAE3E,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,UAAU,CAAC,IAAI,EAAE,CAAC;QACtD,UAAU,GAAG,UAAU,CAAC,IAAI,CAAA;IAC9B,CAAC;IAED,IAAI,UAAU,KAAK,SAAS,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE,CAAC;QAC/D,OAAO,EAAE,CAAA;IACX,CAAC;IAED,OAAO,UAAU,CAAA;AACnB,CAAC","sourcesContent":["import { isHexString, toUtf8String } from 'ethers'\n\nimport { ERROR_PREFIX, PANIC_ERROR_PREFIX } from './constants'\n\nconst panicErrorCodeToReason = (errorCode: bigint): string | undefined => {\n  switch (errorCode) {\n    case 0x0n:\n      return 'Generic compiler inserted panic'\n    case 0x1n:\n      return 'Assertion error'\n    case 0x11n:\n      return 'Arithmetic operation underflowed or overflowed outside of an unchecked block'\n    case 0x12n:\n      return 'Division or modulo division by zero'\n    case 0x21n:\n      return 'Tried to convert a value into an enum, but the value was too big or negative'\n    case 0x22n:\n      return 'Incorrectly encoded storage byte array'\n    case 0x31n:\n      return '.pop() was called on an empty array'\n    case 0x32n:\n      return 'Array accessed at an out-of-bounds or negative index'\n    case 0x41n:\n      return 'Too much memory was allocated, or an array was created that is too large'\n    case 0x51n:\n      return 'Called a zero-initialized variable of internal function type'\n    default:\n      return undefined\n  }\n}\n\nconst isReasonValid = (reason: string | null): boolean => {\n  return (\n    !!reason &&\n    typeof reason === 'string' &&\n    reason !== '0x' &&\n    reason !== 'Unknown error' &&\n    reason !== 'UNKNOWN_ERROR' &&\n    !reason.startsWith(ERROR_PREFIX) &&\n    !reason.startsWith(PANIC_ERROR_PREFIX) &&\n    !reason.toLowerCase().includes('could not coalesce error')\n  )\n}\n\n/**\n * Counts the number of valid Unicode numbers and letters in a string.\n */\nconst countUnicodeLettersAndNumbers = (str: string): number => {\n  let validCount = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charAt(i)\n    // Check if it's an alphabetic character (from any language) or a number\n    if (/[\\p{L}\\p{N}]/u.test(char)) {\n      validCount++\n    }\n  }\n  return validCount\n}\n\n/**\n * Some reasons are encoded in hex, this function will decode them to a human-readable string\n * which can then be matched to a specific error message.\n */\nconst formatReason = (reason: string): string => {\n  const trimmedReason = reason.trim()\n  if (!isHexString(trimmedReason)) return trimmedReason\n  if (trimmedReason.startsWith(ERROR_PREFIX) || trimmedReason.startsWith(PANIC_ERROR_PREFIX))\n    return trimmedReason\n\n  try {\n    const decodedString = toUtf8String(trimmedReason)\n\n    // Return the decoded string if it contains valid Unicode letters\n    return countUnicodeLettersAndNumbers(decodedString) > 0 ? decodedString : trimmedReason\n  } catch {\n    return trimmedReason\n  }\n}\n\nconst getErrorCodeStringFromReason = (reason?: string, withSpace = true): string => {\n  if (!reason || !isReasonValid(reason)) return ''\n\n  const truncatedReason = reason.length > 100 ? `${reason.slice(0, 100)}...` : reason\n\n  return `${withSpace ? ' ' : ''}Error code: ${truncatedReason}`\n}\n\nfunction getDataFromError(error: Error): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const errorData = (error as any).data ?? (error as any).error?.data\n\n  if (errorData === undefined) {\n    return ''\n  }\n\n  let returnData = typeof errorData === 'string' ? errorData : errorData.data\n\n  if (typeof returnData === 'object' && returnData.data) {\n    returnData = returnData.data\n  }\n\n  if (returnData === undefined || typeof returnData !== 'string') {\n    return ''\n  }\n\n  return returnData\n}\n\nexport {\n  panicErrorCodeToReason,\n  getErrorCodeStringFromReason,\n  isReasonValid,\n  getDataFromError,\n  formatReason,\n  countUnicodeLettersAndNumbers\n}\n"]}