{"version":3,"file":"errorDecoder.js","sourceRoot":"","sources":["../../../../src/libs/errorDecoder/errorDecoder.ts"],"names":[],"mappings":";;;;AAAA,iDAA6C;AAC7C,yCASmB;AACnB,2EAAgE;AAChE,yEAA8D;AAC9D,yEAAoD;AACpD,uCAAyE;AACzE,mCAAiD;AAEjD,MAAM,6BAA6B,GAAG;IACpC,kBAA8B;IAC9B,iBAA6B;CAC9B,CAAA;AAED,MAAM,qBAAqB,GAAG,CAAC,8BAAmB,EAAE,iBAAmB,EAAE,kCAAuB,CAAC,CAAA;AACjG,MAAM,cAAc,GAAG;IACrB,0BAAe;IACf,6BAAkB;IAClB,4BAAiB;IACjB,6BAAkB;IAClB,gCAAqB;IACrB,+BAAoB;CACrB,CAAA;AAED,mEAAmE;AACnE,uDAAuD;AACvD,SAAgB,WAAW,CAAC,CAAQ;IAClC,iDAAiD;IACjD,oCAAoC;IACpC,IACE,CAAC,YAAY,SAAS;QACtB,CAAC,YAAY,cAAc;QAC3B,CAAC,YAAY,WAAW;QACxB,CAAC,YAAY,UAAU,EACvB;QACA,OAAO,CAAC,KAAK,CAAC,0BAA0B,EAAE,CAAC,CAAC,CAAA;QAE5C,OAAO;YACL,IAAI,EAAE,iBAAS,CAAC,SAAS;YACzB,MAAM,EAAE,CAAC,CAAC,IAAI;YACd,IAAI,EAAE,IAAI;SACX,CAAA;KACF;IAED,MAAM,SAAS,GAAG,IAAA,0BAAgB,EAAC,CAAC,CAAC,CAAA;IAErC,IAAI,YAAY,GAAiB;QAC/B,IAAI,EAAE,iBAAS,CAAC,YAAY;QAC5B,MAAM,EAAE,EAAE;QACV,IAAI,EAAE,SAAS;KAChB,CAAA;IAED,2DAA2D;IAC3D,yEAAyE;IACzE,mFAAmF;IACnF,yDAAyD;IACzD,MAAM,oBAAoB,GAAG,qBAAqB,CAAA;IAClD,IAAI,CAAC,YAAY,2BAAY,EAAE;QAC7B,oBAAoB,CAAC,IAAI,CAAC,GAAG,6BAA6B,CAAC,CAAA;KAC5D;IAED,kCAAkC;IAClC,qEAAqE;IACrE,iEAAiE;IACjE,oBAAoB,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;QAC5C,MAAM,OAAO,GAAG,IAAI,YAAY,EAAE,CAAA;QAClC,IAAI,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE;YACjC,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAA;SAC5C;IACH,CAAC,CAAC,CAAA;IAEF,qBAAqB;IACrB,cAAc,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;QACtC,MAAM,OAAO,GAAG,IAAI,YAAY,EAAE,CAAA;QAClC,MAAM,aAAa,GAAG,IAAA,uBAAa,EAAC,YAAY,CAAC,MAAM,CAAC,CAAA;QACxD,MAAM,aAAa,GAAG,YAAY,CAAC,IAAI,IAAI,SAAS,CAAA;QAEpD,IAAI,OAAO,CAAC,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,EAAE;YACvD,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAA;SAChD;IACH,CAAC,CAAC,CAAA;IAEF,YAAY,CAAC,MAAM,GAAG,IAAA,sBAAY,EAAC,YAAY,CAAC,MAAM,IAAI,EAAE,CAAC,CAAA;IAE7D,IAAI,YAAY,CAAC,IAAI,KAAK,iBAAS,CAAC,YAAY,EAAE;QAChD,OAAO,CAAC,KAAK,CAAC,wBAAwB,EAAE,CAAC,CAAC,CAAA;KAC3C;IAED,OAAO,YAAY,CAAA;AACrB,CAAC;AA/DD,kCA+DC","sourcesContent":["import { BundlerError } from './customErrors'\nimport {\n  BundlerErrorHandler,\n  CustomErrorHandler,\n  InnerCallFailureHandler,\n  PanicErrorHandler,\n  PaymasterErrorHandler,\n  RevertErrorHandler,\n  RpcErrorHandler,\n  UserRejectionHandler\n} from './handlers'\nimport BiconomyEstimationErrorHandler from './handlers/biconomy'\nimport PimlicoEstimationErrorHandler from './handlers/pimlico'\nimport RelayerErrorHandler from './handlers/relayer'\nimport { formatReason, getDataFromError, isReasonValid } from './helpers'\nimport { DecodedError, ErrorType } from './types'\n\nconst PREPROCESSOR_BUNDLER_HANDLERS = [\n  BiconomyEstimationErrorHandler,\n  PimlicoEstimationErrorHandler\n]\n\nconst PREPROCESSOR_HANDLERS = [BundlerErrorHandler, RelayerErrorHandler, InnerCallFailureHandler]\nconst ERROR_HANDLERS = [\n  RpcErrorHandler,\n  CustomErrorHandler,\n  PanicErrorHandler,\n  RevertErrorHandler,\n  PaymasterErrorHandler,\n  UserRejectionHandler\n]\n\n// additionalHandlers is a list of handlers we want to add only for\n// specific decodeError cases (e.g. bundler estimation)\nexport function decodeError(e: Error): DecodedError {\n  // Otherwise regular JS/TS errors will be handled\n  // as RPC errors which is confusing.\n  if (\n    e instanceof TypeError ||\n    e instanceof ReferenceError ||\n    e instanceof SyntaxError ||\n    e instanceof RangeError\n  ) {\n    console.error('Encountered a code error', e)\n\n    return {\n      type: ErrorType.CodeError,\n      reason: e.name,\n      data: null\n    }\n  }\n\n  const errorData = getDataFromError(e)\n\n  let decodedError: DecodedError = {\n    type: ErrorType.UnknownError,\n    reason: '',\n    data: errorData\n  }\n\n  // configure a list of preprocessorHandlers we want to use.\n  // There are very generic errors like 400 bad request that when they come\n  // from a bundler that mean one thing but from an RPC another, and from the relayer\n  // a third. So we will add additional handlers optionally\n  const preprocessorHandlers = PREPROCESSOR_HANDLERS\n  if (e instanceof BundlerError) {\n    preprocessorHandlers.push(...PREPROCESSOR_BUNDLER_HANDLERS)\n  }\n\n  // Run preprocessor handlers first\n  // The idea is that preprocessor handlers can either decode the error\n  // or leave it partially decoded for the other handlers to decode\n  preprocessorHandlers.forEach((HandlerClass) => {\n    const handler = new HandlerClass()\n    if (handler.matches(errorData, e)) {\n      decodedError = handler.handle(errorData, e)\n    }\n  })\n\n  // Run error handlers\n  ERROR_HANDLERS.forEach((HandlerClass) => {\n    const handler = new HandlerClass()\n    const isValidReason = isReasonValid(decodedError.reason)\n    const processedData = decodedError.data || errorData\n\n    if (handler.matches(processedData, e) && !isValidReason) {\n      decodedError = handler.handle(processedData, e)\n    }\n  })\n\n  decodedError.reason = formatReason(decodedError.reason || '')\n\n  if (decodedError.type === ErrorType.UnknownError) {\n    console.error('Failed to decode error', e)\n  }\n\n  return decodedError\n}\n"]}