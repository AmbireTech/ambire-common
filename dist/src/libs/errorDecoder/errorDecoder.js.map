{"version":3,"file":"errorDecoder.js","sourceRoot":"","sources":["../../../../src/libs/errorDecoder/errorDecoder.ts"],"names":[],"mappings":";;AAwCA,kCA8CC;;AAtFD,iDAA6C;AAC7C,yCASmB;AACnB,2EAAgE;AAChE,2EAAiD;AACjD,yEAA8D;AAC9D,yEAAoD;AACpD,uCAAyE;AACzE,mCAAiD;AAEjD,4CAA4C;AAC5C,2EAA2E;AAC3E,6EAA6E;AAC7E,oEAAoE;AACpE,mFAAmF;AACnF,MAAM,6BAA6B,GAAG;IACpC,kBAA8B;IAC9B,iBAA6B;CAC9B,CAAA;AACD,MAAM,qBAAqB,GAAG,CAAC,8BAAmB,EAAE,iBAAmB,EAAE,kCAAuB,CAAC,CAAA;AACjG,MAAM,cAAc,GAAG;IACrB,kBAAe;IACf,0BAAe;IACf,6BAAkB;IAClB,4BAAiB;IACjB,6BAAkB;IAClB,gCAAqB;IACrB,+BAAoB;CACrB,CAAA;AAED,mEAAmE;AACnE,uDAAuD;AACvD,SAAgB,WAAW,CAAC,CAAQ;IAClC,MAAM,SAAS,GAAG,IAAA,0BAAgB,EAAC,CAAC,CAAC,CAAA;IAErC,IAAI,YAAY,GAAiB;QAC/B,IAAI,EAAE,iBAAS,CAAC,YAAY;QAC5B,MAAM,EAAE,EAAE;QACV,IAAI,EAAE,SAAS;KAChB,CAAA;IAED,2DAA2D;IAC3D,yEAAyE;IACzE,mFAAmF;IACnF,yDAAyD;IACzD,MAAM,oBAAoB,GAAG,qBAAqB,CAAA;IAClD,IAAI,CAAC,YAAY,2BAAY,EAAE,CAAC;QAC9B,oBAAoB,CAAC,OAAO,CAAC,GAAG,6BAA6B,CAAC,CAAA;IAChE,CAAC;IAED,kCAAkC;IAClC,qEAAqE;IACrE,iEAAiE;IACjE,oBAAoB,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;QAC5C,MAAM,OAAO,GAAG,IAAI,YAAY,EAAE,CAAA;QAClC,IAAI,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC;YAClC,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAA;QAC7C,CAAC;IACH,CAAC,CAAC,CAAA;IAEF,qBAAqB;IACrB,cAAc,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;QACtC,MAAM,OAAO,GAAG,IAAI,YAAY,EAAE,CAAA;QAClC,MAAM,aAAa,GAAG,IAAA,uBAAa,EAAC,YAAY,CAAC,MAAM,CAAC,CAAA;QACxD,MAAM,aAAa,GAAG,YAAY,CAAC,IAAI,IAAI,SAAS,CAAA;QAEpD,IAAI,OAAO,CAAC,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;YACxD,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAA;QACjD,CAAC;IACH,CAAC,CAAC,CAAA;IAEF,YAAY,CAAC,MAAM,GAAG,IAAA,sBAAY,EAAC,YAAY,CAAC,MAAM,IAAI,EAAE,CAAC,CAAA;IAE7D,IAAI,YAAY,CAAC,IAAI,KAAK,iBAAS,CAAC,YAAY,EAAE,CAAC;QACjD,OAAO,CAAC,KAAK,CAAC,wBAAwB,EAAE,CAAC,CAAC,CAAA;IAC5C,CAAC;IAED,OAAO,YAAY,CAAA;AACrB,CAAC","sourcesContent":["import { BundlerError } from './customErrors'\nimport {\n  BundlerErrorHandler,\n  CustomErrorHandler,\n  InnerCallFailureHandler,\n  PanicErrorHandler,\n  PaymasterErrorHandler,\n  RevertErrorHandler,\n  RpcErrorHandler,\n  UserRejectionHandler\n} from './handlers'\nimport BiconomyEstimationErrorHandler from './handlers/biconomy'\nimport InternalHandler from './handlers/internal'\nimport PimlicoEstimationErrorHandler from './handlers/pimlico'\nimport RelayerErrorHandler from './handlers/relayer'\nimport { formatReason, getDataFromError, isReasonValid } from './helpers'\nimport { DecodedError, ErrorType } from './types'\n\n// The order of these handlers is important!\n// Preprocessor handlers must be ordered by least specific to most specific\n// Why- because error reasons are overwritten by subsequent matching handlers\n// Error handlers must be ordered by most specific to least specific\n// Why- because the first valid reason cannot be overwritten by subsequent handlers\nconst PREPROCESSOR_BUNDLER_HANDLERS = [\n  BiconomyEstimationErrorHandler,\n  PimlicoEstimationErrorHandler\n]\nconst PREPROCESSOR_HANDLERS = [BundlerErrorHandler, RelayerErrorHandler, InnerCallFailureHandler]\nconst ERROR_HANDLERS = [\n  InternalHandler,\n  RpcErrorHandler,\n  CustomErrorHandler,\n  PanicErrorHandler,\n  RevertErrorHandler,\n  PaymasterErrorHandler,\n  UserRejectionHandler\n]\n\n// additionalHandlers is a list of handlers we want to add only for\n// specific decodeError cases (e.g. bundler estimation)\nexport function decodeError(e: Error): DecodedError {\n  const errorData = getDataFromError(e)\n\n  let decodedError: DecodedError = {\n    type: ErrorType.UnknownError,\n    reason: '',\n    data: errorData\n  }\n\n  // configure a list of preprocessorHandlers we want to use.\n  // There are very generic errors like 400 bad request that when they come\n  // from a bundler that mean one thing but from an RPC another, and from the relayer\n  // a third. So we will add additional handlers optionally\n  const preprocessorHandlers = PREPROCESSOR_HANDLERS\n  if (e instanceof BundlerError) {\n    preprocessorHandlers.unshift(...PREPROCESSOR_BUNDLER_HANDLERS)\n  }\n\n  // Run preprocessor handlers first\n  // The idea is that preprocessor handlers can either decode the error\n  // or leave it partially decoded for the other handlers to decode\n  preprocessorHandlers.forEach((HandlerClass) => {\n    const handler = new HandlerClass()\n    if (handler.matches(errorData, e)) {\n      decodedError = handler.handle(errorData, e)\n    }\n  })\n\n  // Run error handlers\n  ERROR_HANDLERS.forEach((HandlerClass) => {\n    const handler = new HandlerClass()\n    const isValidReason = isReasonValid(decodedError.reason)\n    const processedData = decodedError.data || errorData\n\n    if (handler.matches(processedData, e) && !isValidReason) {\n      decodedError = handler.handle(processedData, e)\n    }\n  })\n\n  decodedError.reason = formatReason(decodedError.reason || '')\n\n  if (decodedError.type === ErrorType.UnknownError) {\n    console.error('Failed to decode error', e)\n  }\n\n  return decodedError\n}\n"]}