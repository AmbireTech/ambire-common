{"version":3,"file":"rpc.js","sourceRoot":"","sources":["../../../../../src/libs/errorDecoder/handlers/rpc.ts"],"names":[],"mappings":";;;AAAA,2CAA2C;AAC3C,wCAA0C;AAC1C,oCAAgE;AAChE,mDAAsE;AAEzD,QAAA,oBAAoB,GAAG;IAClC,UAAU,EAAE,aAAa;CAC1B,CAAA;AAED,MAAM,eAAe;IACZ,OAAO,CAAC,IAAY,EAAE,KAAU;QACrC,+EAA+E;QAC/E,qEAAqE;QACrE,IAAI,KAAK,EAAE,OAAO,KAAK,4BAAoB,CAAC,UAAU;YAAE,OAAO,IAAI,CAAA;QAEnE,OAAO,CACL,CAAC,IAAI;YACL,CAAC,CAAC,KAAK,CAAC,OAAO;YACf,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,sBAAsB,CAAC;YACjD,8DAA8D;YAC9D,KAAK,EAAE,IAAI,KAAK,SAAS;YACzB,KAAK,CAAC,IAAI,KAAK,oDAAoC,CACpD,CAAA;IACH,CAAC;IAEM,MAAM,CAAC,IAAY,EAAE,KAAY;QACtC,MAAM,QAAQ,GAAG,KAAY,CAAA;QAC7B,8EAA8E;QAC9E,0FAA0F;QAC1F,MAAM,eAAe,GAAG;YACtB,QAAQ,CAAC,IAAI;YACb,QAAQ,CAAC,YAAY;YACrB,QAAQ,CAAC,OAAO;YAChB,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO;YAC7B,QAAQ,CAAC,KAAK,EAAE,OAAO;SACxB,CAAA;QAED,MAAM,MAAM,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,IAAA,uBAAa,EAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;QAEzE,OAAO;YACL,IAAI,EAAE,iBAAS,CAAC,QAAQ;YACxB,MAAM;YACN,IAAI;SACL,CAAA;IACH,CAAC;CACF;AAED,kBAAe,eAAe,CAAA","sourcesContent":["/* eslint-disable class-methods-use-this */\nimport { isReasonValid } from '../helpers'\nimport { DecodedError, ErrorHandler, ErrorType } from '../types'\nimport { USER_REJECTED_TRANSACTION_ERROR_CODE } from './userRejection'\n\nexport const RPC_HARDCODED_ERRORS = {\n  rpcTimeout: 'rpc-timeout'\n}\n\nclass RpcErrorHandler implements ErrorHandler {\n  public matches(data: string, error: any) {\n    // This is the only case in which we want to check for a specific error message\n    // because it's a custom error that should be handled as an RPC error\n    if (error?.message === RPC_HARDCODED_ERRORS.rpcTimeout) return true\n\n    return (\n      !data &&\n      !!error.message &&\n      !error?.message?.includes('rejected transaction') &&\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      error?.code !== undefined &&\n      error.code !== USER_REJECTED_TRANSACTION_ERROR_CODE\n    )\n  }\n\n  public handle(data: string, error: Error): DecodedError {\n    const rpcError = error as any\n    // The order is important here, we want to prioritize the most relevant reason\n    // Also, we do it this way as the reason can be in different places depending on the error\n    const possibleReasons = [\n      rpcError.code,\n      rpcError.shortMessage,\n      rpcError.message,\n      rpcError.info?.error?.message,\n      rpcError.error?.message\n    ]\n\n    const reason = possibleReasons.find((r) => !!r && isReasonValid(r)) || ''\n\n    return {\n      type: ErrorType.RpcError,\n      reason,\n      data\n    }\n  }\n}\n\nexport default RpcErrorHandler\n"]}