{"version":3,"file":"relayer.js","sourceRoot":"","sources":["../../../../../src/libs/errorDecoder/handlers/relayer.ts"],"names":[],"mappings":"AAAA,2CAA2C;AAC3C,OAAO,EAAE,oBAAoB,EAAE,YAAY,EAAE,MAAM,+BAA+B,CAAA;AAClF,OAAO,EAAE,aAAa,EAAE,MAAM,YAAY,CAAA;AAC1C,OAAO,EAA8B,SAAS,EAAE,MAAM,UAAU,CAAA;AAEhE,MAAM,mBAAmB;IAChB,OAAO,CAAC,IAAY,EAAE,KAAU;QACrC,MAAM,EAAE,OAAO,EAAE,GAAG,KAAK,IAAI,EAAE,CAAA;QAE/B,IAAI,OAAO,KAAK,oBAAoB;YAAE,OAAO,IAAI,CAAA;QAEjD,OAAO,KAAK,YAAY,YAAY,CAAA;IACtC,CAAC;IAEM,MAAM,CAAC,IAAY,EAAE,KAAU;QACpC,IAAI,MAAM,GAAG,EAAE,CAAA;QACf,IAAI,SAAS,GAAG,EAAE,CAAA;QAElB,IAAI,KAAK,CAAC,OAAO,KAAK,oBAAoB,EAAE;YAC1C,kBAAkB;YAClB,MAAM,GAAG,oBAAoB,CAAA;SAC9B;aAAM;YACL,+BAA+B;YAC/B,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;YAC3D,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;YAE5D,oDAAoD;YACpD,qCAAqC;YACrC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE;gBACxC,MAAM,GAAG,KAAK,CAAC,OAAO,CAAA;aACvB;SACF;QAED,OAAO;YACL,IAAI,EAAE,SAAS,CAAC,YAAY;YAC5B,MAAM;YACN,IAAI,EAAE,SAAS;SAChB,CAAA;IACH,CAAC;CACF;AAED,eAAe,mBAAmB,CAAA","sourcesContent":["/* eslint-disable class-methods-use-this */\nimport { RELAYER_DOWN_MESSAGE, RelayerError } from '../../relayerCall/relayerCall'\nimport { isReasonValid } from '../helpers'\nimport { DecodedError, ErrorHandler, ErrorType } from '../types'\n\nclass RelayerErrorHandler implements ErrorHandler {\n  public matches(data: string, error: any) {\n    const { message } = error || {}\n\n    if (message === RELAYER_DOWN_MESSAGE) return true\n\n    return error instanceof RelayerError\n  }\n\n  public handle(data: string, error: any): DecodedError {\n    let reason = ''\n    let finalData = ''\n\n    if (error.message === RELAYER_DOWN_MESSAGE) {\n      // Relayer is down\n      reason = RELAYER_DOWN_MESSAGE\n    } else {\n      // RPC error returned as string\n      reason = error.message.match(/reason=\"([^\"]*)\"/)?.[1] || ''\n      finalData = error.message.match(/data=\"([^\"]*)\"/)?.[1] || ''\n\n      // The response isn't a stringified RPC error so the\n      // reason is likely the error message\n      if (!isReasonValid(reason) && !finalData) {\n        reason = error.message\n      }\n    }\n\n    return {\n      type: ErrorType.RelayerError,\n      reason,\n      data: finalData\n    }\n  }\n}\n\nexport default RelayerErrorHandler\n"]}