{"version":3,"file":"innerCallFailure.js","sourceRoot":"","sources":["../../../../../src/libs/errorDecoder/handlers/innerCallFailure.ts"],"names":[],"mappings":"AAEA,OAAO,EAA8B,SAAS,EAAE,MAAM,UAAU,CAAA;AAEhE,MAAM,uBAAuB;IAC3B,IAAI,GAAG,SAAS,CAAC,qBAAqB,CAAA;IAE/B,OAAO,CAAC,IAAY,EAAE,KAAY;QACvC,OAAO,KAAK,CAAC,IAAI,KAAK,uBAAuB,CAAA;IAC/C,CAAC;IAEM,MAAM,CAAC,IAAY,EAAE,KAAY;QACtC,MAAM,cAAc,GAAG,KAA8B,CAAA;QACrD,MAAM,SAAS,GAAG,cAAc,CAAC,OAAO,KAAK,IAAI,CAAA;QAEjD,6CAA6C;QAC7C,IAAI,CAAC,SAAS,EAAE;YACd,MAAM,MAAM,GAAG,cAAc,CAAC,OAAO,CAAA;YACrC,OAAO;gBACL,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,MAAM;gBACN,IAAI,EAAE,MAAM;aACb,CAAA;SACF;QAED,mEAAmE;QACnE,+DAA+D;QAC/D,IAAI,cAAc,CAAC,oBAAoB,KAAK,SAAS,EAAE;YACrD,MAAM,MAAM,GAAG,gBAAgB,CAAA;YAC/B,OAAO;gBACL,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,MAAM;gBACN,IAAI,EAAE,MAAM;aACb,CAAA;SACF;QAED,IAAI,WAAW,GAAG,EAAE,CAAA;QACpB,cAAc,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACpC,WAAW,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE,CAAA;QACjC,CAAC,CAAC,CAAA;QACF,MAAM,8BAA8B,GAAG,WAAW,GAAG,cAAc,CAAC,oBAAqB,CAAA;QACzF,MAAM,MAAM,GAAG,8BAA8B;YAC3C,CAAC,CAAC,gBAAgB,cAAc,CAAC,OAAO,CAAC,iBAAiB,wBAAwB;YAClF,CAAC,CAAC,gBAAgB,CAAA;QAEpB,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,MAAM;YACN,IAAI,EAAE,MAAM;SACb,CAAA;IACH,CAAC;CACF;AAED,eAAe,uBAAuB,CAAA","sourcesContent":["/* eslint-disable class-methods-use-this */\nimport { InnerCallFailureError } from '../customErrors'\nimport { DecodedError, ErrorHandler, ErrorType } from '../types'\n\nclass InnerCallFailureHandler implements ErrorHandler {\n  type = ErrorType.InnerCallFailureError\n\n  public matches(data: string, error: Error) {\n    return error.name === 'InnerCallFailureError'\n  }\n\n  public handle(data: string, error: Error): DecodedError {\n    const innerCallError = error as InnerCallFailureError\n    const isError0x = innerCallError.message === '0x'\n\n    // if an error has been found, report it back\n    if (!isError0x) {\n      const reason = innerCallError.message\n      return {\n        type: this.type,\n        reason,\n        data: reason\n      }\n    }\n\n    // if the error is 0x but we don't have info on the portfolio value\n    // because of an RPC failure or something, return error unknown\n    if (innerCallError.nativePortfolioValue === undefined) {\n      const reason = 'Inner call: 0x'\n      return {\n        type: this.type,\n        reason,\n        data: reason\n      }\n    }\n\n    let callsNative = 0n\n    innerCallError.calls.forEach((call) => {\n      callsNative += call.value ?? 0n\n    })\n    const isCallsNativeMoreThanPortfolio = callsNative > innerCallError.nativePortfolioValue!\n    const reason = isCallsNativeMoreThanPortfolio\n      ? `Insufficient ${innerCallError.network.nativeAssetSymbol} for transaction calls`\n      : 'Inner call: 0x'\n\n    return {\n      type: this.type,\n      reason,\n      data: reason\n    }\n  }\n}\n\nexport default InnerCallFailureHandler\n"]}